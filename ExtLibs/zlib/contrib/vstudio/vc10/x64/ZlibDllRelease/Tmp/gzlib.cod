; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
EXTRN	__imp_wcstombs:PROC
EXTRN	__imp__wopen:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	gz_error
;	COMDAT pdata
; File c:\my\gis\extlibs\zlib\gzlib.c
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN14
	DD	imagerel $LN14+276
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_error
_TEXT	SEGMENT
state$ = 48
err$ = 56
msg$ = 64
gz_error PROC						; COMDAT

; 568  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f1	 mov	 rsi, rcx

; 569  :     /* free previously allocated message and clear */
; 570  :     if (state->msg != NULL) {

  00017	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0001b	33 db		 xor	 ebx, ebx
  0001d	49 8b e8	 mov	 rbp, r8
  00020	8b fa		 mov	 edi, edx
  00022	48 85 c9	 test	 rcx, rcx
  00025	74 10		 je	 SHORT $LN6@gz_error

; 571  :         if (state->err != Z_MEM_ERROR)

  00027	83 7e 6c fc	 cmp	 DWORD PTR [rsi+108], -4
  0002b	74 06		 je	 SHORT $LN5@gz_error

; 572  :             free(state->msg);

  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@gz_error:

; 573  :         state->msg = NULL;

  00033	48 89 5e 70	 mov	 QWORD PTR [rsi+112], rbx
$LN6@gz_error:

; 574  :     }
; 575  : 
; 576  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 577  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00037	85 ff		 test	 edi, edi
  00039	74 07		 je	 SHORT $LN4@gz_error
  0003b	83 ff fb	 cmp	 edi, -5
  0003e	74 02		 je	 SHORT $LN4@gz_error

; 578  :         state->x.have = 0;

  00040	89 1e		 mov	 DWORD PTR [rsi], ebx
$LN4@gz_error:

; 579  : 
; 580  :     /* set error code, and if no message, then done */
; 581  :     state->err = err;

  00042	89 7e 6c	 mov	 DWORD PTR [rsi+108], edi

; 582  :     if (msg == NULL)

  00045	48 85 ed	 test	 rbp, rbp
  00048	0f 84 b1 00 00
	00		 je	 $LN7@gz_error

; 583  :         return;
; 584  : 
; 585  :     /* for an out of memory error, save as static string */
; 586  :     if (err == Z_MEM_ERROR) {

  0004e	83 ff fc	 cmp	 edi, -4
  00051	75 09		 jne	 SHORT $LN2@gz_error

; 587  :         state->msg = (char *)msg;

  00053	48 89 6e 70	 mov	 QWORD PTR [rsi+112], rbp

; 588  :         return;

  00057	e9 a3 00 00 00	 jmp	 $LN7@gz_error
$LN2@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* construct error message with path */
; 592  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  0005c	48 8b 5e 20	 mov	 rbx, QWORD PTR [rsi+32]
  00060	48 83 c9 ff	 or	 rcx, -1
  00064	33 c0		 xor	 eax, eax
  00066	48 8b fb	 mov	 rdi, rbx
  00069	f2 ae		 repne scasb
  0006b	48 8b fd	 mov	 rdi, rbp
  0006e	48 f7 d1	 not	 rcx
  00071	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00075	48 83 c9 ff	 or	 rcx, -1
  00079	f2 ae		 repne scasb
  0007b	48 f7 d1	 not	 rcx
  0007e	48 8d 4c 0a 02	 lea	 rcx, QWORD PTR [rdx+rcx+2]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00089	48 8b d0	 mov	 rdx, rax
  0008c	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00090	48 85 c0	 test	 rax, rax
  00093	75 1b		 jne	 SHORT $LL1@gz_error

; 593  :         state->err = Z_MEM_ERROR;
; 594  :         state->msg = (char *)"out of memory";

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0009c	c7 46 6c fc ff
	ff ff		 mov	 DWORD PTR [rsi+108], -4
  000a3	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax

; 595  :         return;

  000a7	eb 56		 jmp	 SHORT $LN7@gz_error
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL1@gz_error:

; 596  :     }
; 597  :     strcpy(state->msg, state->path);

  000b0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000b3	48 ff c2	 inc	 rdx
  000b6	48 ff c3	 inc	 rbx
  000b9	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  000bc	84 c0		 test	 al, al
  000be	75 f0		 jne	 SHORT $LL1@gz_error

; 598  :     strcat(state->msg, ": ");

  000c0	48 8b 7e 70	 mov	 rdi, QWORD PTR [rsi+112]
  000c4	33 c0		 xor	 eax, eax
  000c6	48 83 c9 ff	 or	 rcx, -1
  000ca	f2 ae		 repne scasb
  000cc	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@

; 599  :     strcat(state->msg, msg);

  000d3	48 83 c9 ff	 or	 rcx, -1
  000d7	66 89 47 ff	 mov	 WORD PTR [rdi-1], ax
  000db	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
  000e2	88 47 01	 mov	 BYTE PTR [rdi+1], al
  000e5	48 8b 7e 70	 mov	 rdi, QWORD PTR [rsi+112]
  000e9	33 c0		 xor	 eax, eax
  000eb	f2 ae		 repne scasb
  000ed	33 c9		 xor	 ecx, ecx
  000ef	90		 npad	 1
$LL11@gz_error:
  000f0	0f b6 04 29	 movzx	 eax, BYTE PTR [rcx+rbp]
  000f4	48 ff c1	 inc	 rcx
  000f7	88 44 0f fe	 mov	 BYTE PTR [rdi+rcx-2], al
  000fb	84 c0		 test	 al, al
  000fd	75 f1		 jne	 SHORT $LL11@gz_error
$LN7@gz_error:

; 600  :     return;
; 601  : }

  000ff	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00104	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00109	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
PUBLIC	gzclearerr
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclearerr DD imagerel $LN8
	DD	imagerel $LN8+54
	DD	imagerel $unwind$gzclearerr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclearerr DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzclearerr
_TEXT	SEGMENT
file$ = 48
gzclearerr PROC						; COMDAT

; 540  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 541  :     gz_statep state;
; 542  : 
; 543  :     /* get internal structure and check integrity */
; 544  :     if (file == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 28		 je	 SHORT $LN4@gzclearerr

; 545  :         return;
; 546  :     state = (gz_statep)file;
; 547  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000c	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00011	74 0e		 je	 SHORT $LN7@gzclearerr
  00013	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00018	75 17		 jne	 SHORT $LN4@gzclearerr

; 548  :         return;
; 549  : 
; 550  :     /* clear error and end-of-file */
; 551  :     if (state->mode == GZ_READ) {

  0001a	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0001f	75 06		 jne	 SHORT $LN1@gzclearerr
$LN7@gzclearerr:

; 552  :         state->eof = 0;

  00021	33 c0		 xor	 eax, eax
  00023	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN1@gzclearerr:

; 553  :         state->past = 0;
; 554  :     }
; 555  :     gz_error(state, Z_OK, NULL);

  00027	45 33 c0	 xor	 r8d, r8d
  0002a	33 d2		 xor	 edx, edx
  0002c	e8 00 00 00 00	 call	 gz_error
$LN4@gzclearerr:

; 556  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
PUBLIC	gzerror
; Function compile flags: /Ogtpy
;	COMDAT gzerror
_TEXT	SEGMENT
file$ = 8
errnum$ = 16
gzerror	PROC						; COMDAT

; 522  :     gz_statep state;
; 523  : 
; 524  :     /* get internal structure and check integrity */
; 525  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 03		 jne	 SHORT $LN3@gzerror
$LN8@gzerror:

; 526  :         return NULL;

  00005	33 c0		 xor	 eax, eax

; 535  : }

  00007	c3		 ret	 0
$LN3@gzerror:

; 527  :     state = (gz_statep)file;
; 528  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00008	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00010	74 07		 je	 SHORT $LN2@gzerror
  00012	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 529  :         return NULL;

  00017	75 ec		 jne	 SHORT $LN8@gzerror
$LN2@gzerror:

; 530  : 
; 531  :     /* return error information */
; 532  :     if (errnum != NULL)

  00019	48 85 d2	 test	 rdx, rdx
  0001c	74 05		 je	 SHORT $LN1@gzerror

; 533  :         *errnum = state->err;

  0001e	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00021	89 02		 mov	 DWORD PTR [rdx], eax
$LN1@gzerror:

; 534  :     return state->msg == NULL ? "" : state->msg;

  00023	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002e	48 85 c9	 test	 rcx, rcx
  00031	48 0f 45 c1	 cmovne	 rax, rcx

; 535  : }

  00035	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
PUBLIC	gzeof
; Function compile flags: /Ogtpy
;	COMDAT gzeof
_TEXT	SEGMENT
file$ = 8
gzeof	PROC						; COMDAT

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure and check integrity */
; 507  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx

; 508  :         return 0;

  00003	74 1c		 je	 SHORT $LN5@gzeof

; 509  :     state = (gz_statep)file;
; 510  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 0e		 je	 SHORT $LN8@gzeof
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 511  :         return 0;

  00014	75 0b		 jne	 SHORT $LN5@gzeof

; 512  : 
; 513  :     /* return end-of-file state */
; 514  :     return state->mode == GZ_READ ? state->past : 0;

  00016	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0001b	75 04		 jne	 SHORT $LN5@gzeof
$LN8@gzeof:
  0001d	8b 41 54	 mov	 eax, DWORD PTR [rcx+84]

; 515  : }

  00020	c3		 ret	 0
$LN5@gzeof:

; 512  : 
; 513  :     /* return end-of-file state */
; 514  :     return state->mode == GZ_READ ? state->past : 0;

  00021	33 c0		 xor	 eax, eax

; 515  : }

  00023	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
PUBLIC	gzoffset64
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN8
	DD	imagerel $LN8+92
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzoffset64
_TEXT	SEGMENT
file$ = 48
gzoffset64 PROC						; COMDAT

; 470  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 471  :     z_off64_t offset;
; 472  :     gz_statep state;
; 473  : 
; 474  :     /* get internal structure and check integrity */
; 475  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN4@gzoffset64
$LN7@gzoffset64:

; 476  :         return -1;

  0000e	48 83 c8 ff	 or	 rax, -1

; 488  : }

  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5b		 pop	 rbx
  00017	c3		 ret	 0
$LN4@gzoffset64:

; 477  :     state = (gz_statep)file;
; 478  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00018	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0001b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00020	74 07		 je	 SHORT $LN3@gzoffset64
  00022	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 479  :         return -1;

  00027	75 e5		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 480  : 
; 481  :     /* compute and return effective offset in file */
; 482  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00029	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0002c	33 d2		 xor	 edx, edx
  0002e	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00038	4c 8b d8	 mov	 r11, rax

; 483  :     if (offset == -1)

  0003b	48 83 f8 ff	 cmp	 rax, -1

; 484  :         return -1;

  0003f	74 cd		 je	 SHORT $LN7@gzoffset64

; 485  :     if (state->mode == GZ_READ)             /* reading */

  00041	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  00048	75 09		 jne	 SHORT $LN1@gzoffset64

; 486  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0004a	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  00050	4c 2b d8	 sub	 r11, rax
$LN1@gzoffset64:

; 487  :     return offset;

  00053	49 8b c3	 mov	 rax, r11

; 488  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
PUBLIC	gztell64
; Function compile flags: /Ogtpy
;	COMDAT gztell64
_TEXT	SEGMENT
file$ = 8
gztell64 PROC						; COMDAT

; 444  :     gz_statep state;
; 445  : 
; 446  :     /* get internal structure and check integrity */
; 447  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 448  :         return -1;

  00005	48 83 c8 ff	 or	 rax, -1

; 455  : }

  00009	c3		 ret	 0
$LN2@gztell64:

; 449  :     state = (gz_statep)file;
; 450  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN1@gztell64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 451  :         return -1;

  00019	75 ea		 jne	 SHORT $LN7@gztell64
$LN1@gztell64:

; 452  : 
; 453  :     /* return position */
; 454  :     return state->x.pos + (state->seek ? state->skip : 0);

  0001b	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  0001f	74 0c		 je	 SHORT $LN5@gztell64
  00021	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00025	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00029	48 03 c2	 add	 rax, rdx

; 455  : }

  0002c	c3		 ret	 0
$LN5@gztell64:

; 452  : 
; 453  :     /* return position */
; 454  :     return state->x.pos + (state->seek ? state->skip : 0);

  0002d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00031	33 d2		 xor	 edx, edx
  00033	48 03 c2	 add	 rax, rdx

; 455  : }

  00036	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
PUBLIC	gzbuffer
; Function compile flags: /Ogtpy
;	COMDAT gzbuffer
_TEXT	SEGMENT
file$ = 8
size$ = 16
gzbuffer PROC						; COMDAT

; 308  :     gz_statep state;
; 309  : 
; 310  :     /* get internal structure and check integrity */
; 311  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 04		 jne	 SHORT $LN4@gzbuffer
$LN7@gzbuffer:

; 312  :         return -1;

  00005	83 c8 ff	 or	 eax, -1

; 326  : }

  00008	c3		 ret	 0
$LN4@gzbuffer:

; 313  :     state = (gz_statep)file;
; 314  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000c	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00011	74 07		 je	 SHORT $LN3@gzbuffer
  00013	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 315  :         return -1;

  00018	75 eb		 jne	 SHORT $LN7@gzbuffer
$LN3@gzbuffer:

; 316  : 
; 317  :     /* make sure we haven't already allocated memory */
; 318  :     if (state->size != 0)

  0001a	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0

; 319  :         return -1;

  0001e	75 e5		 jne	 SHORT $LN7@gzbuffer

; 320  : 
; 321  :     /* check and set requested size */
; 322  :     if (size < 2)

  00020	b8 02 00 00 00	 mov	 eax, 2
  00025	3b d0		 cmp	 edx, eax
  00027	0f 42 d0	 cmovb	 edx, eax

; 323  :         size = 2;               /* need two bytes to check magic header */
; 324  :     state->want = size;
; 325  :     return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	89 51 2c	 mov	 DWORD PTR [rcx+44], edx

; 326  : }

  0002f	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+67
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 77   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 78   :     state->x.have = 0;              /* no output data available */

  0000a	33 ff		 xor	 edi, edi

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000c	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00013	48 8b d9	 mov	 rbx, rcx
  00016	89 39		 mov	 DWORD PTR [rcx], edi
  00018	75 07		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  0001a	48 89 79 50	 mov	 QWORD PTR [rcx+80], rdi

; 81   :         state->past = 0;            /* have not read past end yet */
; 82   :         state->how = LOOK;          /* look for gzip header */

  0001e	89 79 44	 mov	 DWORD PTR [rcx+68], edi
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */
; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00021	45 33 c0	 xor	 r8d, r8d
  00024	33 d2		 xor	 edx, edx
  00026	89 79 68	 mov	 DWORD PTR [rcx+104], edi
  00029	e8 00 00 00 00	 call	 gz_error

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  0002e	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  00032	89 bb 80 00 00
	00		 mov	 DWORD PTR [rbx+128], edi

; 88   : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
gz_reset ENDP
PUBLIC	gzoffset
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$gzoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzoffset
_TEXT	SEGMENT
file$ = 48
gzoffset PROC						; COMDAT

; 493  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 494  :     z_off64_t ret;
; 495  : 
; 496  :     ret = gzoffset64(file);

  00004	e8 00 00 00 00	 call	 gzoffset64
  00009	4c 8b d8	 mov	 r11, rax

; 497  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000c	48 63 c8	 movsxd	 rcx, eax
  0000f	83 c8 ff	 or	 eax, -1
  00012	4c 3b d9	 cmp	 r11, rcx
  00015	41 0f 44 c3	 cmove	 eax, r11d

; 498  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
gzoffset ENDP
_TEXT	ENDS
PUBLIC	gztell
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$gztell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gztell
_TEXT	SEGMENT
file$ = 48
gztell	PROC						; COMDAT

; 460  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 461  :     z_off64_t ret;
; 462  : 
; 463  :     ret = gztell64(file);

  00004	e8 00 00 00 00	 call	 gztell64
  00009	4c 8b c0	 mov	 r8, rax

; 464  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000c	48 63 c8	 movsxd	 rcx, eax
  0000f	83 c8 ff	 or	 eax, -1
  00012	4c 3b c1	 cmp	 r8, rcx
  00015	41 0f 44 c0	 cmove	 eax, r8d

; 465  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
gztell	ENDP
_TEXT	ENDS
PUBLIC	gzrewind
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN7
	DD	imagerel $LN7+82
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzrewind
_TEXT	SEGMENT
file$ = 48
gzrewind PROC						; COMDAT

; 331  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 332  :     gz_statep state;
; 333  : 
; 334  :     /* get internal structure */
; 335  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx

; 336  :         return -1;

  0000c	74 3b		 je	 SHORT $LN2@gzrewind

; 337  :     state = (gz_statep)file;
; 338  : 
; 339  :     /* check that we're reading and that there's no error */
; 340  :     if (state->mode != GZ_READ ||
; 341  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000e	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00015	75 32		 jne	 SHORT $LN2@gzrewind
  00017	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN3@gzrewind
  0001e	83 f8 fb	 cmp	 eax, -5
  00021	75 26		 jne	 SHORT $LN2@gzrewind
$LN3@gzrewind:

; 343  : 
; 344  :     /* back up and start over */
; 345  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00023	48 8b 51 48	 mov	 rdx, QWORD PTR [rcx+72]
  00027	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00033	48 83 f8 ff	 cmp	 rax, -1

; 346  :         return -1;

  00037	74 10		 je	 SHORT $LN2@gzrewind

; 347  :     gz_reset(state);

  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 gz_reset

; 348  :     return 0;

  00041	33 c0		 xor	 eax, eax

; 349  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN2@gzrewind:

; 342  :         return -1;

  00049	83 c8 ff	 or	 eax, -1

; 349  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_open DD imagerel gz_open+52
	DD	imagerel gz_open+269
	DD	imagerel $chain$0$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_open DD imagerel gz_open+269
	DD	imagerel gz_open+310
	DD	imagerel $chain$1$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_open DD imagerel gz_open+310
	DD	imagerel gz_open+339
	DD	imagerel $chain$2$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gz_open DD imagerel gz_open+339
	DD	imagerel gz_open+346
	DD	imagerel $chain$4$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gz_open DD imagerel gz_open+346
	DD	imagerel gz_open+687
	DD	imagerel $chain$5$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gz_open DD imagerel gz_open+687
	DD	imagerel gz_open+712
	DD	imagerel $chain$6$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$gz_open DD imagerel gz_open+712
	DD	imagerel gz_open+834
	DD	imagerel $chain$8$gz_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$gz_open DD 020021H
	DD	0a3400H
	DD	imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gz_open DD 021H
	DD	imagerel gz_open+339
	DD	imagerel gz_open+346
	DD	imagerel $chain$4$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gz_open DD 020521H
	DD	0cc405H
	DD	imagerel gz_open+339
	DD	imagerel gz_open+346
	DD	imagerel $chain$4$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gz_open DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_open DD 021H
	DD	imagerel gz_open+52
	DD	imagerel gz_open+269
	DD	imagerel $chain$0$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_open DD 020521H
	DD	0b5405H
	DD	imagerel gz_open+52
	DD	imagerel gz_open+269
	DD	imagerel $chain$0$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_open DD 020521H
	DD	0a3405H
	DD	imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 060d01H
	DD	0f009320dH
	DD	0d005e007H
	DD	060027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_open
_TEXT	SEGMENT
path$ = 80
fd$ = 88
mode$ = 96
gz_open	PROC						; COMDAT

; 95   : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 96   :     gz_statep state;
; 97   :     size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  0000d	33 f6		 xor	 esi, esi
  0000f	49 8b f8	 mov	 rdi, r8
  00012	44 8b ea	 mov	 r13d, edx
  00015	4c 8b f1	 mov	 r14, rcx
  00018	44 8b fe	 mov	 r15d, esi

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0001b	48 85 c9	 test	 rcx, rcx
  0001e	75 0f		 jne	 SHORT $LN35@gz_open

; 108  :         return NULL;

  00020	33 c0		 xor	 eax, eax

; 259  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	41 5f		 pop	 r15
  00028	41 5e		 pop	 r14
  0002a	41 5d		 pop	 r13
  0002c	5f		 pop	 rdi
  0002d	5e		 pop	 rsi
  0002e	c3		 ret	 0
$LN35@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = malloc(sizeof(gz_state));

  0002f	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00034	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 8b d8	 mov	 rbx, rax

; 112  :     if (state == NULL)

  00042	48 85 c0	 test	 rax, rax

; 113  :         return NULL;

  00045	0f 84 f4 00 00
	00		 je	 $LN57@gz_open

; 114  :     state->size = 0;            /* no buffers allocated yet */

  0004b	89 70 28	 mov	 DWORD PTR [rax+40], esi

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  0004e	c7 40 2c 00 20
	00 00		 mov	 DWORD PTR [rax+44], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  00055	48 89 70 70	 mov	 QWORD PTR [rax+112], rsi

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  00059	89 70 18	 mov	 DWORD PTR [rax+24], esi

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  0005c	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  00063	89 70 5c	 mov	 DWORD PTR [rax+92], esi

; 122  :     state->direct = 0;

  00066	89 70 40	 mov	 DWORD PTR [rax+64], esi

; 123  :     while (*mode) {

  00069	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0006c	41 b8 b1 79 00
	00		 mov	 r8d, 31153		; 000079b1H
  00072	84 c0		 test	 al, al
  00074	0f 84 93 00 00
	00		 je	 $LN50@gz_open
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LL33@gz_open:

; 124  :         if (*mode >= '0' && *mode <= '9')

  00081	3c 30		 cmp	 al, 48			; 00000030H
  00083	7c 0f		 jl	 SHORT $LN31@gz_open
  00085	3c 39		 cmp	 al, 57			; 00000039H
  00087	7f 0b		 jg	 SHORT $LN31@gz_open

; 125  :             state->level = *mode - '0';

  00089	0f be c0	 movsx	 eax, al
  0008c	83 e8 30	 sub	 eax, 48			; 00000030H
  0008f	89 43 58	 mov	 DWORD PTR [rbx+88], eax

; 126  :         else

  00092	eb 6a		 jmp	 SHORT $LN16@gz_open
$LN31@gz_open:

; 127  :             switch (*mode) {

  00094	0f be c0	 movsx	 eax, al
  00097	83 c0 d5	 add	 eax, -43		; ffffffffffffffd5H
  0009a	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0009d	77 5f		 ja	 SHORT $LN16@gz_open
  0009f	48 98		 cdqe
  000a1	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN48@gz_open[rdx+rax]
  000a9	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN49@gz_open[rdx+rax*4]
  000b0	48 03 ca	 add	 rcx, rdx
  000b3	ff e1		 jmp	 rcx
$LN27@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000b5	c7 43 18 4f 1c
	00 00		 mov	 DWORD PTR [rbx+24], 7247 ; 00001c4fH

; 130  :                 break;

  000bc	eb 40		 jmp	 SHORT $LN16@gz_open
$LN26@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  000be	44 89 43 18	 mov	 DWORD PTR [rbx+24], r8d

; 134  :                 break;

  000c2	eb 3a		 jmp	 SHORT $LN16@gz_open
$LN25@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000c4	c7 43 18 01 00
	00 00		 mov	 DWORD PTR [rbx+24], 1

; 137  :                 break;

  000cb	eb 31		 jmp	 SHORT $LN16@gz_open
$LN22@gz_open:

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;
; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  000cd	41 bf 01 00 00
	00		 mov	 r15d, 1

; 152  :                 break;

  000d3	eb 29		 jmp	 SHORT $LN16@gz_open
$LN21@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  000d5	c7 43 5c 01 00
	00 00		 mov	 DWORD PTR [rbx+92], 1

; 156  :                 break;

  000dc	eb 20		 jmp	 SHORT $LN16@gz_open
$LN20@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  000de	c7 43 5c 02 00
	00 00		 mov	 DWORD PTR [rbx+92], 2

; 159  :                 break;

  000e5	eb 17		 jmp	 SHORT $LN16@gz_open
$LN19@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  000e7	c7 43 5c 03 00
	00 00		 mov	 DWORD PTR [rbx+92], 3

; 162  :                 break;

  000ee	eb 0e		 jmp	 SHORT $LN16@gz_open
$LN18@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  000f0	c7 43 5c 04 00
	00 00		 mov	 DWORD PTR [rbx+92], 4
$LN17@gz_open:

; 165  :             case 'T':
; 166  :                 state->direct = 1;

  000f7	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN16@gz_open:

; 123  :     while (*mode) {

  000fe	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]

; 167  :             default:        /* could consider as an error, but just ignore */
; 168  :                 ;
; 169  :             }
; 170  :         mode++;

  00102	48 ff c7	 inc	 rdi
  00105	84 c0		 test	 al, al
  00107	0f 85 74 ff ff
	ff		 jne	 $LL33@gz_open
$LN50@gz_open:
  0010d	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 171  :     }
; 172  : 
; 173  :     /* must provide an "r", "w", or "a" */
; 174  :     if (state->mode == GZ_NONE) {

  00112	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]
  00115	85 ed		 test	 ebp, ebp

; 175  :         free(state);
; 176  :         return NULL;

  00117	74 0d		 je	 SHORT $LN56@gz_open

; 177  :     }
; 178  : 
; 179  :     /* can't force transparent read */
; 180  :     if (state->mode == GZ_READ) {

  00119	81 fd 4f 1c 00
	00		 cmp	 ebp, 7247		; 00001c4fH
  0011f	75 39		 jne	 SHORT $LN14@gz_open

; 181  :         if (state->direct) {

  00121	39 73 40	 cmp	 DWORD PTR [rbx+64], esi
  00124	74 2d		 je	 SHORT $LN13@gz_open
$LN56@gz_open:

; 182  :             free(state);

  00126	48 8b cb	 mov	 rcx, rbx
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 183  :             return NULL;

  0012f	33 c0		 xor	 eax, eax
  00131	e9 79 01 00 00	 jmp	 $LN52@gz_open
$LN24@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  00136	48 8b cb	 mov	 rcx, rbx
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN57@gz_open:

; 141  :                 return NULL;

  0013f	33 c0		 xor	 eax, eax
  00141	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 259  : }

  00146	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014a	41 5f		 pop	 r15
  0014c	41 5e		 pop	 r14
  0014e	41 5d		 pop	 r13
  00150	5f		 pop	 rdi
  00151	5e		 pop	 rsi
  00152	c3		 ret	 0
$LN13@gz_open:

; 184  :         }
; 185  :         state->direct = 1;      /* for empty file */

  00153	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN14@gz_open:
  0015a	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12

; 186  :     }
; 187  : 
; 188  :     /* save the path name for error messages */
; 189  : #ifdef _WIN32
; 190  :     if (fd == -2) {

  0015f	41 83 fd fe	 cmp	 r13d, -2
  00163	75 1c		 jne	 SHORT $LN12@gz_open

; 191  :         len = wcstombs(NULL, path, 0);

  00165	45 33 c0	 xor	 r8d, r8d
  00168	49 8b d6	 mov	 rdx, r14
  0016b	33 c9		 xor	 ecx, ecx
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00173	48 8b f8	 mov	 rdi, rax

; 192  :         if (len == (size_t)-1)

  00176	48 83 f8 ff	 cmp	 rax, -1
  0017a	75 17		 jne	 SHORT $LN10@gz_open

; 193  :             len = 0;

  0017c	48 8b fe	 mov	 rdi, rsi

; 194  :     }
; 195  :     else

  0017f	eb 12		 jmp	 SHORT $LN10@gz_open
$LN12@gz_open:

; 196  : #endif
; 197  :         len = strlen(path);

  00181	48 83 c9 ff	 or	 rcx, -1
  00185	33 c0		 xor	 eax, eax
  00187	49 8b fe	 mov	 rdi, r14
  0018a	f2 ae		 repne scasb
  0018c	48 f7 d1	 not	 rcx
  0018f	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
$LN10@gz_open:

; 198  :     state->path = malloc(len + 1);

  00193	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0019d	48 8b f0	 mov	 rsi, rax
  001a0	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 199  :     if (state->path == NULL) {

  001a4	48 85 c0	 test	 rax, rax

; 200  :         free(state);
; 201  :         return NULL;

  001a7	0f 84 b2 00 00
	00		 je	 $LN55@gz_open

; 202  :     }
; 203  : #ifdef _WIN32
; 204  :     if (fd == -2)

  001ad	41 83 fd fe	 cmp	 r13d, -2
  001b1	75 1c		 jne	 SHORT $LN8@gz_open

; 205  :         if (len)

  001b3	48 85 ff	 test	 rdi, rdi
  001b6	74 12		 je	 SHORT $LN7@gz_open

; 206  :             wcstombs(state->path, path, len + 1);

  001b8	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  001bc	49 8b d6	 mov	 rdx, r14
  001bf	48 8b c8	 mov	 rcx, rax
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs

; 207  :         else

  001c8	eb 26		 jmp	 SHORT $LN5@gz_open
$LN7@gz_open:

; 208  :             *(state->path) = 0;

  001ca	c6 00 00	 mov	 BYTE PTR [rax], 0

; 209  :     else

  001cd	eb 21		 jmp	 SHORT $LN5@gz_open
$LN8@gz_open:

; 210  : #endif
; 211  :         strcpy(state->path, path);

  001cf	49 8b ce	 mov	 rcx, r14
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL38@gz_open:
  001e0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001e3	48 ff c2	 inc	 rdx
  001e6	48 ff c1	 inc	 rcx
  001e9	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  001ec	84 c0		 test	 al, al
  001ee	75 f0		 jne	 SHORT $LL38@gz_open
$LN5@gz_open:

; 212  : 
; 213  :     /* compute the flags for open() */
; 214  :     oflag =
; 215  : #ifdef O_LARGEFILE
; 216  :         O_LARGEFILE |
; 217  : #endif
; 218  : #ifdef O_BINARY
; 219  :         O_BINARY |
; 220  : #endif
; 221  : #ifdef O_CLOEXEC
; 222  :         (cloexec ? O_CLOEXEC : 0) |
; 223  : #endif
; 224  :         (state->mode == GZ_READ ?
; 225  :          O_RDONLY :
; 226  :          (O_WRONLY | O_CREAT |
; 227  : #ifdef O_EXCL
; 228  :           (exclusive ? O_EXCL : 0) |
; 229  : #endif
; 230  :           (state->mode == GZ_WRITE ?
; 231  :            O_TRUNC :
; 232  :            O_APPEND)));

  001f0	bf b1 79 00 00	 mov	 edi, 31153		; 000079b1H
  001f5	81 fd 4f 1c 00
	00		 cmp	 ebp, 7247		; 00001c4fH
  001fb	75 04		 jne	 SHORT $LN39@gz_open
  001fd	33 d2		 xor	 edx, edx
  001ff	eb 21		 jmp	 SHORT $LN40@gz_open
$LN39@gz_open:
  00201	3b ef		 cmp	 ebp, edi
  00203	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00208	ba 08 00 00 00	 mov	 edx, 8
  0020d	0f 44 d0	 cmove	 edx, eax
  00210	41 f7 df	 neg	 r15d
  00213	1b c0		 sbb	 eax, eax
  00215	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0021a	0b d0		 or	 edx, eax
  0021c	81 ca 01 01 00
	00		 or	 edx, 257		; 00000101H
$LN40@gz_open:
  00222	0f ba ea 0f	 bts	 edx, 15

; 233  : 
; 234  :     /* open the file with the appropriate flags (or just use fd) */
; 235  :     state->fd = fd > -1 ? fd : (
; 236  : #ifdef _WIN32
; 237  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 238  : #endif
; 239  :         open(path, oflag, 0666));

  00226	41 83 fd ff	 cmp	 r13d, -1
  0022a	7f 20		 jg	 SHORT $LN42@gz_open
  0022c	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00232	49 8b ce	 mov	 rcx, r14
  00235	41 83 fd fe	 cmp	 r13d, -2
  00239	75 08		 jne	 SHORT $LN41@gz_open
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
  00241	eb 06		 jmp	 SHORT $LN54@gz_open
$LN41@gz_open:
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
$LN54@gz_open:
  00249	44 8b e8	 mov	 r13d, eax
$LN42@gz_open:
  0024c	44 89 6b 1c	 mov	 DWORD PTR [rbx+28], r13d

; 240  :     if (state->fd == -1) {

  00250	41 83 fd ff	 cmp	 r13d, -1
  00254	75 16		 jne	 SHORT $LN4@gz_open

; 241  :         free(state->path);

  00256	48 8b ce	 mov	 rcx, rsi
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN55@gz_open:

; 242  :         free(state);

  0025f	48 8b cb	 mov	 rcx, rbx
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 243  :         return NULL;

  00268	33 c0		 xor	 eax, eax
  0026a	eb 3e		 jmp	 SHORT $LN53@gz_open
$LN4@gz_open:

; 244  :     }
; 245  :     if (state->mode == GZ_APPEND)

  0026c	83 fd 01	 cmp	 ebp, 1
  0026f	8b c5		 mov	 eax, ebp
  00271	0f 44 c7	 cmove	 eax, edi
  00274	89 43 18	 mov	 DWORD PTR [rbx+24], eax

; 246  :         state->mode = GZ_WRITE;         /* simplify later checks */
; 247  : 
; 248  :     /* save the current position for rewinding (only if reading) */
; 249  :     if (state->mode == GZ_READ) {

  00277	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0027c	75 21		 jne	 SHORT $LN1@gz_open

; 250  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  0027e	33 d2		 xor	 edx, edx
  00280	41 8b cd	 mov	 ecx, r13d
  00283	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  0028d	48 89 43 48	 mov	 QWORD PTR [rbx+72], rax

; 251  :         if (state->start == -1) state->start = 0;

  00291	48 83 f8 ff	 cmp	 rax, -1
  00295	75 08		 jne	 SHORT $LN1@gz_open
  00297	48 c7 43 48 00
	00 00 00	 mov	 QWORD PTR [rbx+72], 0
$LN1@gz_open:

; 252  :     }
; 253  : 
; 254  :     /* initialize stream */
; 255  :     gz_reset(state);

  0029f	48 8b cb	 mov	 rcx, rbx
  002a2	e8 00 00 00 00	 call	 gz_reset

; 256  : 
; 257  :     /* return stream */
; 258  :     return (gzFile)state;

  002a7	48 8b c3	 mov	 rax, rbx
$LN53@gz_open:
  002aa	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
$LN52@gz_open:
  002af	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  002b4	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 259  : }

  002b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002bd	41 5f		 pop	 r15
  002bf	41 5e		 pop	 r14
  002c1	41 5d		 pop	 r13
  002c3	5f		 pop	 rdi
  002c4	5e		 pop	 rsi
  002c5	c3		 ret	 0
  002c6	66 90		 npad	 2
$LN49@gz_open:
  002c8	00 00 00 00	 DD	 $LN24@gz_open
  002cc	00 00 00 00	 DD	 $LN18@gz_open
  002d0	00 00 00 00	 DD	 $LN19@gz_open
  002d4	00 00 00 00	 DD	 $LN17@gz_open
  002d8	00 00 00 00	 DD	 $LN25@gz_open
  002dc	00 00 00 00	 DD	 $LN21@gz_open
  002e0	00 00 00 00	 DD	 $LN20@gz_open
  002e4	00 00 00 00	 DD	 $LN27@gz_open
  002e8	00 00 00 00	 DD	 $LN26@gz_open
  002ec	00 00 00 00	 DD	 $LN22@gz_open
  002f0	00 00 00 00	 DD	 $LN16@gz_open
$LN48@gz_open:
  002f4	00		 DB	 0
  002f5	0a		 DB	 10
  002f6	0a		 DB	 10
  002f7	0a		 DB	 10
  002f8	0a		 DB	 10
  002f9	0a		 DB	 10
  002fa	0a		 DB	 10
  002fb	0a		 DB	 10
  002fc	0a		 DB	 10
  002fd	0a		 DB	 10
  002fe	0a		 DB	 10
  002ff	0a		 DB	 10
  00300	0a		 DB	 10
  00301	0a		 DB	 10
  00302	0a		 DB	 10
  00303	0a		 DB	 10
  00304	0a		 DB	 10
  00305	0a		 DB	 10
  00306	0a		 DB	 10
  00307	0a		 DB	 10
  00308	0a		 DB	 10
  00309	0a		 DB	 10
  0030a	0a		 DB	 10
  0030b	0a		 DB	 10
  0030c	0a		 DB	 10
  0030d	0a		 DB	 10
  0030e	0a		 DB	 10
  0030f	01		 DB	 1
  00310	0a		 DB	 10
  00311	0a		 DB	 10
  00312	0a		 DB	 10
  00313	0a		 DB	 10
  00314	0a		 DB	 10
  00315	0a		 DB	 10
  00316	0a		 DB	 10
  00317	0a		 DB	 10
  00318	0a		 DB	 10
  00319	0a		 DB	 10
  0031a	0a		 DB	 10
  0031b	02		 DB	 2
  0031c	0a		 DB	 10
  0031d	03		 DB	 3
  0031e	0a		 DB	 10
  0031f	0a		 DB	 10
  00320	0a		 DB	 10
  00321	0a		 DB	 10
  00322	0a		 DB	 10
  00323	0a		 DB	 10
  00324	0a		 DB	 10
  00325	0a		 DB	 10
  00326	0a		 DB	 10
  00327	0a		 DB	 10
  00328	0a		 DB	 10
  00329	0a		 DB	 10
  0032a	04		 DB	 4
  0032b	0a		 DB	 10
  0032c	0a		 DB	 10
  0032d	0a		 DB	 10
  0032e	0a		 DB	 10
  0032f	05		 DB	 5
  00330	0a		 DB	 10
  00331	06		 DB	 6
  00332	0a		 DB	 10
  00333	0a		 DB	 10
  00334	0a		 DB	 10
  00335	0a		 DB	 10
  00336	0a		 DB	 10
  00337	0a		 DB	 10
  00338	0a		 DB	 10
  00339	0a		 DB	 10
  0033a	0a		 DB	 10
  0033b	07		 DB	 7
  0033c	0a		 DB	 10
  0033d	0a		 DB	 10
  0033e	0a		 DB	 10
  0033f	0a		 DB	 10
  00340	08		 DB	 8
  00341	09		 DB	 9
gz_open	ENDP
PUBLIC	gzseek64
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN24
	DD	imagerel $LN24+94
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzseek64 DD imagerel $LN24+94
	DD	imagerel $LN24+210
	DD	imagerel $chain$0$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzseek64 DD imagerel $LN24+210
	DD	imagerel $LN24+262
	DD	imagerel $chain$2$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gzseek64 DD imagerel $LN24+262
	DD	imagerel $LN24+337
	DD	imagerel $chain$4$gzseek64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN24
	DD	imagerel $LN24+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN24
	DD	imagerel $LN24+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzseek64 DD 020521H
	DD	066405H
	DD	imagerel $LN24
	DD	imagerel $LN24+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzseek64
_TEXT	SEGMENT
file$ = 48
offset$ = 56
whence$ = 64
gzseek64 PROC						; COMDAT

; 356  : {

$LN24:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 357  :     unsigned n;
; 358  :     z_off64_t ret;
; 359  :     gz_statep state;
; 360  : 
; 361  :     /* get internal structure and check integrity */
; 362  :     if (file == NULL)

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 0f		 jne	 SHORT $LN15@gzseek64
$LN23@gzseek64:

; 363  :         return -1;

  00015	48 83 c8 ff	 or	 rax, -1

; 426  : }

  00019	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN15@gzseek64:

; 364  :     state = (gz_statep)file;
; 365  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00024	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00027	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0002d	74 08		 je	 SHORT $LN14@gzseek64
  0002f	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H

; 366  :         return -1;

  00035	75 de		 jne	 SHORT $LN23@gzseek64
$LN14@gzseek64:

; 367  : 
; 368  :     /* check that there's no error */
; 369  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00037	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0003a	85 c0		 test	 eax, eax
  0003c	74 05		 je	 SHORT $LN13@gzseek64
  0003e	83 f8 fb	 cmp	 eax, -5

; 370  :         return -1;

  00041	75 d2		 jne	 SHORT $LN23@gzseek64
$LN13@gzseek64:

; 371  : 
; 372  :     /* can only seek from start or relative to current position */
; 373  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00043	45 85 c0	 test	 r8d, r8d
  00046	74 12		 je	 SHORT $LN20@gzseek64
  00048	41 83 f8 01	 cmp	 r8d, 1

; 374  :         return -1;

  0004c	75 c7		 jne	 SHORT $LN23@gzseek64

; 379  :     else if (state->seek)

  0004e	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00052	74 0a		 je	 SHORT $LN9@gzseek64

; 380  :         offset += state->skip;

  00054	48 03 79 60	 add	 rdi, QWORD PTR [rcx+96]
  00058	eb 04		 jmp	 SHORT $LN9@gzseek64
$LN20@gzseek64:

; 375  : 
; 376  :     /* normalize offset to a SEEK_CUR specification */
; 377  :     if (whence == SEEK_SET)
; 378  :         offset -= state->x.pos;

  0005a	48 2b 79 10	 sub	 rdi, QWORD PTR [rcx+16]
$LN9@gzseek64:
  0005e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 381  :     state->seek = 0;

  00063	33 f6		 xor	 esi, esi
  00065	89 71 68	 mov	 DWORD PTR [rcx+104], esi

; 382  : 
; 383  :     /* if within raw area while reading, just go there */
; 384  :     if (state->mode == GZ_READ && state->how == COPY &&
; 385  :             state->x.pos + offset >= 0) {

  00068	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0006e	75 62		 jne	 SHORT $LN8@gzseek64
  00070	83 79 44 01	 cmp	 DWORD PTR [rcx+68], 1
  00074	75 5c		 jne	 SHORT $LN8@gzseek64
  00076	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0007a	48 8d 0c 07	 lea	 rcx, QWORD PTR [rdi+rax]
  0007e	48 85 c9	 test	 rcx, rcx
  00081	78 4f		 js	 SHORT $LN8@gzseek64

; 386  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
; 387  :         if (ret == -1)

  00083	8b 03		 mov	 eax, DWORD PTR [rbx]
  00085	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00088	48 8b d7	 mov	 rdx, rdi
  0008b	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  0008f	48 2b d0	 sub	 rdx, rax
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00098	48 83 f8 ff	 cmp	 rax, -1

; 388  :             return -1;

  0009c	74 54		 je	 SHORT $LN22@gzseek64

; 389  :         state->x.have = 0;
; 390  :         state->eof = 0;
; 391  :         state->past = 0;
; 392  :         state->seek = 0;
; 393  :         gz_error(state, Z_OK, NULL);

  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	33 d2		 xor	 edx, edx
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	89 33		 mov	 DWORD PTR [rbx], esi
  000a8	48 89 73 50	 mov	 QWORD PTR [rbx+80], rsi
  000ac	89 73 68	 mov	 DWORD PTR [rbx+104], esi
  000af	e8 00 00 00 00	 call	 gz_error

; 394  :         state->strm.avail_in = 0;
; 395  :         state->x.pos += offset;

  000b4	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 396  :         return state->x.pos;

  000b8	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000bc	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi
  000c2	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 426  : }

  000c7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN8@gzseek64:

; 397  :     }
; 398  : 
; 399  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 400  :     if (offset < 0) {

  000d2	48 85 ff	 test	 rdi, rdi
  000d5	79 2f		 jns	 SHORT $LN3@gzseek64

; 401  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000d7	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH

; 402  :             return -1;

  000dd	75 13		 jne	 SHORT $LN22@gzseek64

; 403  :         offset += state->x.pos;

  000df	48 03 7b 10	 add	 rdi, QWORD PTR [rbx+16]

; 404  :         if (offset < 0)                     /* before start of file! */
; 405  :             return -1;

  000e3	78 0d		 js	 SHORT $LN22@gzseek64

; 406  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	e8 00 00 00 00	 call	 gzrewind
  000ed	83 f8 ff	 cmp	 eax, -1
  000f0	75 14		 jne	 SHORT $LN3@gzseek64
$LN22@gzseek64:

; 407  :             return -1;

  000f2	48 83 c8 ff	 or	 rax, -1
  000f6	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 426  : }

  000fb	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00100	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
$LN3@gzseek64:

; 408  :     }
; 409  : 
; 410  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 411  :     if (state->mode == GZ_READ) {

  00106	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  0010d	75 1b		 jne	 SHORT $LN2@gzseek64

; 412  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 413  :             (unsigned)offset : state->x.have;

  0010f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00111	8b cf		 mov	 ecx, edi
  00113	48 3b c7	 cmp	 rax, rdi
  00116	0f 4e c8	 cmovle	 ecx, eax

; 414  :         state->x.have -= n;

  00119	2b c1		 sub	 eax, ecx
  0011b	89 03		 mov	 DWORD PTR [rbx], eax

; 415  :         state->x.next += n;

  0011d	8b c1		 mov	 eax, ecx
  0011f	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 416  :         state->x.pos += n;

  00123	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 417  :         offset -= n;

  00127	48 2b f8	 sub	 rdi, rax
$LN2@gzseek64:

; 418  :     }
; 419  : 
; 420  :     /* request skip (if not zero) */
; 421  :     if (offset) {

  0012a	48 85 ff	 test	 rdi, rdi
  0012d	74 0b		 je	 SHORT $LN1@gzseek64

; 422  :         state->seek = 1;

  0012f	c7 43 68 01 00
	00 00		 mov	 DWORD PTR [rbx+104], 1

; 423  :         state->skip = offset;

  00136	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
$LN1@gzseek64:

; 424  :     }
; 425  :     return state->x.pos + offset;

  0013a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0013e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 426  : }

  00143	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00148	48 03 c7	 add	 rax, rdi
  0014b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014f	5f		 pop	 rdi
  00150	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
PUBLIC	gzopen_w
; Function compile flags: /Ogtpy
;	COMDAT gzopen_w
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen_w PROC						; COMDAT

; 299  :     return gz_open(path, -2, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	ba fe ff ff ff	 mov	 edx, -2

; 300  : }

  00008	e9 00 00 00 00	 jmp	 gz_open
gzopen_w ENDP
_TEXT	ENDS
PUBLIC	gzdopen
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN5
	DD	imagerel $LN5+125
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzdopen
_TEXT	SEGMENT
fd$ = 48
mode$ = 56
gzdopen	PROC						; COMDAT

; 281  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	8b d9		 mov	 ebx, ecx

; 282  :     char *path;         /* identifier for error messages */
; 283  :     gzFile gz;
; 284  : 
; 285  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00014	83 f9 ff	 cmp	 ecx, -1
  00017	74 52		 je	 SHORT $LN1@gzdopen
  00019	b9 13 00 00 00	 mov	 ecx, 19
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 85 c0	 test	 rax, rax
  0002a	74 3f		 je	 SHORT $LN1@gzdopen

; 286  :         return NULL;
; 287  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00033	44 8b c3	 mov	 r8d, ebx
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 288  :     gz = gz_open(path, fd, mode);

  0003f	4c 8b c6	 mov	 r8, rsi
  00042	8b d3		 mov	 edx, ebx
  00044	48 8b cf	 mov	 rcx, rdi
  00047	e8 00 00 00 00	 call	 gz_open

; 289  :     free(path);

  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	48 8b d8	 mov	 rbx, rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 290  :     return gz;

  00058	48 8b c3	 mov	 rax, rbx

; 291  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN1@gzdopen:
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00075	33 c0		 xor	 eax, eax
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
PUBLIC	gzopen
; Function compile flags: /Ogtpy
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen	PROC						; COMDAT

; 266  :     return gz_open(path, -1, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	83 ca ff	 or	 edx, -1

; 267  : }

  00006	e9 00 00 00 00	 jmp	 gz_open
gzopen	ENDP
PUBLIC	gzseek
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$gzseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzseek
_TEXT	SEGMENT
file$ = 48
offset$ = 56
whence$ = 64
gzseek	PROC						; COMDAT

; 433  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 434  :     z_off64_t ret;
; 435  : 
; 436  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00004	48 63 d2	 movsxd	 rdx, edx
  00007	e8 00 00 00 00	 call	 gzseek64
  0000c	4c 8b d8	 mov	 r11, rax

; 437  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000f	48 63 c8	 movsxd	 rcx, eax
  00012	83 c8 ff	 or	 eax, -1
  00015	4c 3b d9	 cmp	 r11, rcx
  00018	41 0f 44 c3	 cmove	 eax, r11d

; 438  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
gzseek	ENDP
END
