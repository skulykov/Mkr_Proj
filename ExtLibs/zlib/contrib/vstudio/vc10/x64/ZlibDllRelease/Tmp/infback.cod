; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	inflateBackEnd
;	COMDAT pdata
; File c:\my\gis\extlibs\zlib\infback.c
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN1@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN1@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN1@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 637  :     strm->state = Z_NULL;

  00026	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 640  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 640  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 121  :     state->distcode = distfix;
; 122  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN12+83
	DD	imagerel $LN12+197
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN12+197
	DD	imagerel $LN12+230
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN12+230
	DD	imagerel $LN12+272
	DD	imagerel $chain$4$inflateBackInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07c400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07c40aH
	DD	066405H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN12:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b fa		 mov	 edi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 db 00 00
	00		 je	 $LN6@inflateBac@2
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d1 00 00
	00		 jne	 $LN6@inflateBac@2
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c6 00 00
	00		 jne	 $LN6@inflateBac@2

; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 a8 00 00
	00		 je	 $LN4@inflateBac@2
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 9f 00 00
	00		 je	 $LN4@inflateBac@2
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 93 00 00
	00		 ja	 $LN4@inflateBac@2

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00053	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00058	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0005d	45 33 e4	 xor	 r12d, r12d
  00060	4c 89 61 20	 mov	 QWORD PTR [rcx+32], r12

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00064	4c 39 61 30	 cmp	 QWORD PTR [rcx+48], r12
  00068	75 0f		 jne	 SHORT $LN3@inflateBac@2

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00071	4c 89 61 40	 mov	 QWORD PTR [rcx+64], r12
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@inflateBac@2:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00079	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;
; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  00084	be 01 00 00 00	 mov	 esi, 1
  00089	49 3b c4	 cmp	 rax, r12
  0008c	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00092	8b d6		 mov	 edx, esi
  00094	48 0f 44 c1	 cmove	 rax, rcx
  00098	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009c	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  000a0	ff 53 30	 call	 QWORD PTR [rbx+48]

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	48 85 c0	 test	 rax, rax
  000a6	75 1d		 jne	 SHORT $LN1@inflateBac@2
  000a8	8d 46 fb	 lea	 eax, QWORD PTR [rsi-5]
$LN11@inflateBac@2:
  000ab	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000b0	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]

; 70   : }

  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN1@inflateBac@2:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c5	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000c9	8b cf		 mov	 ecx, edi
  000cb	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H
  000d2	d3 e6		 shl	 esi, cl
  000d4	89 78 28	 mov	 DWORD PTR [rax+40], edi

; 66   :     state->window = window;

  000d7	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000db	89 70 2c	 mov	 DWORD PTR [rax+44], esi

; 67   :     state->wnext = 0;

  000de	4c 89 60 30	 mov	 QWORD PTR [rax+48], r12

; 68   :     state->whave = 0;
; 69   :     return Z_OK;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb c5		 jmp	 SHORT $LN11@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  000e6	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000eb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
$LN6@inflateBac@2:
  000fb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00100	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00105	b8 fa ff ff ff	 mov	 eax, -6
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
inflateBackInit_ ENDP
PUBLIC	inflateBack
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN442
	DD	imagerel $LN442+66
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN442+66
	DD	imagerel $LN442+3742
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN442+3742
	DD	imagerel $LN442+3760
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateBack DD imagerel $LN442+3760
	DD	imagerel $LN442+3836
	DD	imagerel $chain$5$inflateBack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateBack DD 080021H
	DD	0bd400H
	DD	0c7400H
	DD	0d6400H
	DD	0e3400H
	DD	imagerel $LN442
	DD	imagerel $LN442+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN442
	DD	imagerel $LN442+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0bd422H
	DD	0c741eH
	DD	0d6408H
	DD	0e3404H
	DD	imagerel $LN442
	DD	imagerel $LN442+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016e018H
	DD	05014H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN442:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b f8	 mov	 r15, r8
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b c1	 mov	 r8, rcx

; 257  :     struct inflate_state FAR *state;
; 258  :     unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 6b 0e 00
	00		 je	 $LN333@inflateBac@3
  00033	4c 8b 71 28	 mov	 r14, QWORD PTR [rcx+40]
  00037	4d 85 f6	 test	 r14, r14
  0003a	0f 84 5e 0e 00
	00		 je	 $LN333@inflateBac@3

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	33 d2		 xor	 edx, edx
  00042	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  0004e	49 c7 06 0b 00
	00 00		 mov	 QWORD PTR [r14], 11

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  00055	41 89 56 30	 mov	 DWORD PTR [r14+48], edx

; 282  :     next = strm->next_in;

  00059	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0005c	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  00060	4c 89 68 c0	 mov	 QWORD PTR [rax-64], r13
  00064	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00068	4d 85 d2	 test	 r10, r10
  0006b	74 05		 je	 SHORT $LN337@inflateBac@3
  0006d	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00070	eb 02		 jmp	 SHORT $LN338@inflateBac@3
$LN337@inflateBac@3:
  00072	8b fa		 mov	 edi, edx
$LN338@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00074	41 8b 06	 mov	 eax, DWORD PTR [r14]
  00077	49 8b 5e 38	 mov	 rbx, QWORD PTR [r14+56]
  0007b	45 8b 4e 2c	 mov	 r9d, DWORD PTR [r14+44]
  0007f	83 e8 0b	 sub	 eax, 11
  00082	44 8b ea	 mov	 r13d, edx
  00085	8b f2		 mov	 esi, edx
  00087	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008b	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  0008f	83 f8 12	 cmp	 eax, 18
  00092	0f 87 d3 0d 00
	00		 ja	 $LN1@inflateBac@3
$LN437@inflateBac@3:
  00098	48 98		 cdqe
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a1	41 bb 01 00 00
	00		 mov	 r11d, 1
  000a7	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN414@inflateBac@3[rcx+rax*4]
  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000b5	48 03 c8	 add	 rcx, rax
  000b8	ff e1		 jmp	 rcx
$LN328@inflateBac@3:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000ba	41 83 7e 04 00	 cmp	 DWORD PTR [r14+4], 0
  000bf	74 1a		 je	 SHORT $LN323@inflateBac@3

; 295  :                 BYTEBITS();

  000c1	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c3	41 c7 06 1c 00
	00 00		 mov	 DWORD PTR [r14], 28

; 297  :                 break;

  000ca	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  000ce	83 e1 07	 and	 ecx, 7
  000d1	41 d3 ed	 shr	 r13d, cl
  000d4	2b f1		 sub	 esi, ecx
  000d6	e9 db 09 00 00	 jmp	 $LN387@inflateBac@3
$LN323@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  000db	83 fe 03	 cmp	 esi, 3
  000de	73 42		 jae	 SHORT $LN322@inflateBac@3
$LL320@inflateBac@3:
  000e0	85 ff		 test	 edi, edi
  000e2	75 18		 jne	 SHORT $LN314@inflateBac@3
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cf	 mov	 rcx, r15
  000eb	41 ff d4	 call	 r12
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 30 0d 00
	00		 je	 $LN363@inflateBac@3
  000f8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN314@inflateBac@3:
  000fc	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  00100	8b ce		 mov	 ecx, esi
  00102	49 ff c2	 inc	 r10
  00105	d3 e2		 shl	 edx, cl
  00107	83 c6 08	 add	 esi, 8
  0010a	ff cf		 dec	 edi
  0010c	44 03 ea	 add	 r13d, edx
  0010f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00113	83 fe 03	 cmp	 esi, 3
  00116	72 c8		 jb	 SHORT $LL320@inflateBac@3
  00118	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0011c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00120	33 d2		 xor	 edx, edx
$LN322@inflateBac@3:

; 300  :             state->last = BITS(1);

  00122	41 8b c5	 mov	 eax, r13d

; 301  :             DROPBITS(1);

  00125	41 d1 ed	 shr	 r13d, 1
  00128	ff ce		 dec	 esi
  0012a	83 e0 01	 and	 eax, 1
  0012d	41 89 46 04	 mov	 DWORD PTR [r14+4], eax

; 302  :             switch (BITS(2)) {

  00131	41 8b c5	 mov	 eax, r13d
  00134	83 e0 03	 and	 eax, 3
  00137	74 64		 je	 SHORT $LN305@inflateBac@3
  00139	ff c8		 dec	 eax
  0013b	74 41		 je	 SHORT $LN304@inflateBac@3
  0013d	ff c8		 dec	 eax
  0013f	74 26		 je	 SHORT $LN303@inflateBac@3
  00141	ff c8		 dec	 eax
  00143	75 5f		 jne	 SHORT $LN301@inflateBac@3

; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0014c	41 c1 ed 02	 shr	 r13d, 2
  00150	83 c6 fe	 add	 esi, -2			; fffffffeH
  00153	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00157	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 324  :             break;

  0015e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00162	e9 4f 09 00 00	 jmp	 $LN387@inflateBac@3
$LN303@inflateBac@3:

; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  00167	41 c7 06 10 00
	00 00		 mov	 DWORD PTR [r14], 16

; 324  :             break;

  0016e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00172	41 c1 ed 02	 shr	 r13d, 2
  00176	83 c6 fe	 add	 esi, -2			; fffffffeH
  00179	e9 38 09 00 00	 jmp	 $LN387@inflateBac@3
$LN304@inflateBac@3:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  0017e	49 8b ce	 mov	 rcx, r14
  00181	e8 00 00 00 00	 call	 fixedtables

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  00186	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 324  :             break;

  0018d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00191	41 c1 ed 02	 shr	 r13d, 2
  00195	83 c6 fe	 add	 esi, -2			; fffffffeH
  00198	e9 19 09 00 00	 jmp	 $LN387@inflateBac@3
$LN305@inflateBac@3:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  0019d	41 c7 06 0d 00
	00 00		 mov	 DWORD PTR [r14], 13
$LN301@inflateBac@3:

; 324  :             break;

  001a4	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  001a8	41 c1 ed 02	 shr	 r13d, 2
  001ac	83 c6 fe	 add	 esi, -2			; fffffffeH
  001af	e9 02 09 00 00	 jmp	 $LN387@inflateBac@3
$LN297@inflateBac@3:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001b4	8b ce		 mov	 ecx, esi
  001b6	83 e1 07	 and	 ecx, 7
  001b9	2b f1		 sub	 esi, ecx
  001bb	41 d3 ed	 shr	 r13d, cl

; 329  :             NEEDBITS(32);

  001be	83 fe 20	 cmp	 esi, 32			; 00000020H
  001c1	73 42		 jae	 SHORT $LN293@inflateBac@3
$LL291@inflateBac@3:
  001c3	85 ff		 test	 edi, edi
  001c5	75 18		 jne	 SHORT $LN285@inflateBac@3
  001c7	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001cb	49 8b cf	 mov	 rcx, r15
  001ce	41 ff d4	 call	 r12
  001d1	8b f8		 mov	 edi, eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 4d 0c 00
	00		 je	 $LN363@inflateBac@3
  001db	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN285@inflateBac@3:
  001df	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001e3	8b ce		 mov	 ecx, esi
  001e5	49 ff c2	 inc	 r10
  001e8	d3 e0		 shl	 eax, cl
  001ea	83 c6 08	 add	 esi, 8
  001ed	ff cf		 dec	 edi
  001ef	44 03 e8	 add	 r13d, eax
  001f2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  001f6	83 fe 20	 cmp	 esi, 32			; 00000020H
  001f9	72 c8		 jb	 SHORT $LL291@inflateBac@3
  001fb	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ff	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00203	33 d2		 xor	 edx, edx
$LN293@inflateBac@3:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00205	41 8b c5	 mov	 eax, r13d
  00208	41 0f b7 cd	 movzx	 ecx, r13w
  0020c	f7 d0		 not	 eax
  0020e	c1 e8 10	 shr	 eax, 16
  00211	3b c8		 cmp	 ecx, eax
  00213	74 1b		 je	 SHORT $LN281@inflateBac@3

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0021c	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 332  :                 state->mode = BAD;

  00220	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 333  :                 break;

  00227	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0022b	e9 86 08 00 00	 jmp	 $LN387@inflateBac@3
$LN281@inflateBac@3:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00230	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  00234	44 8b ea	 mov	 r13d, edx
  00237	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00239	85 c9		 test	 ecx, ecx
  0023b	0f 84 97 00 00
	00		 je	 $LN276@inflateBac@3
$LL277@inflateBac@3:

; 342  :                 copy = state->length;

  00241	45 8b 66 48	 mov	 r12d, DWORD PTR [r14+72]

; 343  :                 PULL();

  00245	85 ff		 test	 edi, edi
  00247	75 14		 jne	 SHORT $LN274@inflateBac@3
  00249	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0024d	49 8b cf	 mov	 rcx, r15
  00250	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00253	8b f8		 mov	 edi, eax
  00255	85 c0		 test	 eax, eax
  00257	0f 84 cb 0b 00
	00		 je	 $LN363@inflateBac@3
$LN274@inflateBac@3:

; 344  :                 ROOM();

  0025d	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  00260	85 db		 test	 ebx, ebx
  00262	75 28		 jne	 SHORT $LN269@inflateBac@3
  00264	41 8b 5e 2c	 mov	 ebx, DWORD PTR [r14+44]
  00268	49 8b 46 38	 mov	 rax, QWORD PTR [r14+56]
  0026c	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00270	44 8b c3	 mov	 r8d, ebx
  00273	48 8b d0	 mov	 rdx, rax
  00276	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0027a	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  0027d	41 89 5e 30	 mov	 DWORD PTR [r14+48], ebx
  00281	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00284	85 c0		 test	 eax, eax
  00286	0f 85 d4 07 00
	00		 jne	 $LN366@inflateBac@3
$LN269@inflateBac@3:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  0028c	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00290	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00294	44 3b e7	 cmp	 r12d, edi
  00297	44 0f 47 e7	 cmova	 r12d, edi
  0029b	44 3b e3	 cmp	 r12d, ebx
  0029e	44 0f 47 e3	 cmova	 r12d, ebx
  002a2	45 8b c4	 mov	 r8d, r12d
  002a5	41 8b dc	 mov	 ebx, r12d
  002a8	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;
; 350  :                 left -= copy;

  002ad	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002b1	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 351  :                 put += copy;

  002b5	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx

; 352  :                 state->length -= copy;

  002b9	45 29 66 48	 sub	 DWORD PTR [r14+72], r12d
  002bd	45 2b cc	 sub	 r9d, r12d
  002c0	41 2b fc	 sub	 edi, r12d
  002c3	41 83 7e 48 00	 cmp	 DWORD PTR [r14+72], 0
  002c8	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002cc	0f 85 6f ff ff
	ff		 jne	 $LL277@inflateBac@3
  002d2	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002d6	33 d2		 xor	 edx, edx
$LN276@inflateBac@3:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  002d8	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11

; 356  :             break;

  002df	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  002e3	e9 ca 07 00 00	 jmp	 $LN430@inflateBac@3
$LN262@inflateBac@3:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002e8	83 fe 0e	 cmp	 esi, 14
  002eb	73 43		 jae	 SHORT $LN261@inflateBac@3
  002ed	0f 1f 00	 npad	 3
$LL259@inflateBac@3:
  002f0	85 ff		 test	 edi, edi
  002f2	75 18		 jne	 SHORT $LN253@inflateBac@3
  002f4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002f8	49 8b cf	 mov	 rcx, r15
  002fb	41 ff d4	 call	 r12
  002fe	8b f8		 mov	 edi, eax
  00300	85 c0		 test	 eax, eax
  00302	0f 84 20 0b 00
	00		 je	 $LN363@inflateBac@3
  00308	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN253@inflateBac@3:
  0030c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00310	8b ce		 mov	 ecx, esi
  00312	49 ff c2	 inc	 r10
  00315	d3 e0		 shl	 eax, cl
  00317	83 c6 08	 add	 esi, 8
  0031a	ff cf		 dec	 edi
  0031c	44 03 e8	 add	 r13d, eax
  0031f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00323	83 fe 0e	 cmp	 esi, 14
  00326	72 c8		 jb	 SHORT $LL259@inflateBac@3
  00328	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0032c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN261@inflateBac@3:

; 361  :             state->nlen = BITS(5) + 257;

  00330	41 8b c5	 mov	 eax, r13d

; 362  :             DROPBITS(5);

  00333	41 c1 ed 05	 shr	 r13d, 5

; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  00337	83 c6 f2	 add	 esi, -14		; fffffff2H
  0033a	41 8b cd	 mov	 ecx, r13d
  0033d	41 c1 ed 05	 shr	 r13d, 5
  00341	83 e0 1f	 and	 eax, 31
  00344	41 8b d5	 mov	 edx, r13d
  00347	83 e1 1f	 and	 ecx, 31
  0034a	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0034f	83 e2 0f	 and	 edx, 15
  00352	ff c1		 inc	 ecx
  00354	41 c1 ed 04	 shr	 r13d, 4
  00358	83 c2 04	 add	 edx, 4
  0035b	41 89 46 74	 mov	 DWORD PTR [r14+116], eax
  0035f	41 89 4e 78	 mov	 DWORD PTR [r14+120], ecx
  00363	41 89 56 70	 mov	 DWORD PTR [r14+112], edx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00367	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  0036c	0f 87 32 05 00
	00		 ja	 $LN239@inflateBac@3
  00372	83 f9 1e	 cmp	 ecx, 30
  00375	0f 87 29 05 00
	00		 ja	 $LN239@inflateBac@3

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0037b	33 db		 xor	 ebx, ebx

; 378  :             while (state->have < state->ncode) {

  0037d	85 d2		 test	 edx, edx
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00386	41 89 5e 7c	 mov	 DWORD PTR [r14+124], ebx
  0038a	0f 84 80 00 00
	00		 je	 $LN346@inflateBac@3
$LL238@inflateBac@3:

; 379  :                 NEEDBITS(3);

  00390	83 fe 03	 cmp	 esi, 3
  00393	73 49		 jae	 SHORT $LN235@inflateBac@3
  00395	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00399	0f 1f 80 00 00
	00 00		 npad	 7
$LL233@inflateBac@3:
  003a0	85 ff		 test	 edi, edi
  003a2	75 18		 jne	 SHORT $LN227@inflateBac@3
  003a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003a8	49 8b cf	 mov	 rcx, r15
  003ab	41 ff d4	 call	 r12
  003ae	8b f8		 mov	 edi, eax
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 7b 0a 00
	00		 je	 $LN368@inflateBac@3
  003b8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN227@inflateBac@3:
  003bc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003bf	8b ce		 mov	 ecx, esi
  003c1	48 ff c2	 inc	 rdx
  003c4	d3 e0		 shl	 eax, cl
  003c6	83 c6 08	 add	 esi, 8
  003c9	ff cf		 dec	 edi
  003cb	44 03 e8	 add	 r13d, eax
  003ce	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003d2	83 fe 03	 cmp	 esi, 3
  003d5	72 c9		 jb	 SHORT $LL233@inflateBac@3
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN235@inflateBac@3:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003de	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  003e2	41 0f b7 cd	 movzx	 ecx, r13w

; 381  :                 DROPBITS(3);

  003e6	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e9	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  003f1	66 83 e1 07	 and	 cx, 7
  003f5	41 c1 ed 03	 shr	 r13d, 3
  003f9	66 41 89 8c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], cx
  00402	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00406	41 8b 46 70	 mov	 eax, DWORD PTR [r14+112]
  0040a	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  0040e	72 80		 jb	 SHORT $LL238@inflateBac@3
$LN346@inflateBac@3:

; 382  :             }
; 383  :             while (state->have < 19)

  00410	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  00415	73 29		 jae	 SHORT $LN219@inflateBac@3
  00417	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL220@inflateBac@3:

; 384  :                 state->lens[order[state->have++]] = 0;

  00420	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00424	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0042c	66 41 89 9c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], bx
  00435	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00439	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  0043e	72 e0		 jb	 SHORT $LL220@inflateBac@3
$LN219@inflateBac@3:

; 385  :             state->next = state->codes;

  00440	49 8d 8e 48 05
	00 00		 lea	 rcx, QWORD PTR [r14+1352]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  00447	49 8d 5e 68	 lea	 rbx, QWORD PTR [r14+104]

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  0044b	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00452	49 89 8e 80 00
	00 00		 mov	 QWORD PTR [r14+128], rcx
  00459	49 89 4e 58	 mov	 QWORD PTR [r14+88], rcx
  0045d	49 8d 8e 08 03
	00 00		 lea	 rcx, QWORD PTR [r14+776]
  00464	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00469	33 c9		 xor	 ecx, ecx
  0046b	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00472	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00476	c7 03 07 00 00
	00		 mov	 DWORD PTR [rbx], 7
  0047c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00481	e8 00 00 00 00	 call	 inflate_table

; 390  :             if (ret) {

  00486	85 c0		 test	 eax, eax
  00488	74 29		 je	 SHORT $LN218@inflateBac@3

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  0048a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN439@inflateBac@3:
  00491	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00495	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00499	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0049d	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  004a1	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  004a8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004ac	33 d2		 xor	 edx, edx
  004ae	e9 03 06 00 00	 jmp	 $LN387@inflateBac@3
$LN218@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004b3	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  004b7	41 c7 46 7c 00
	00 00 00	 mov	 DWORD PTR [r14+124], 0
  004bf	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004c3	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  004c7	0f 84 63 02 00
	00		 je	 $LN216@inflateBac@3
  004cd	0f 1f 00	 npad	 3
$LL217@inflateBac@3:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004d0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004d2	b8 01 00 00 00	 mov	 eax, 1
  004d7	d3 e0		 shl	 eax, cl
  004d9	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004dc	41 8b c5	 mov	 eax, r13d
  004df	48 23 c8	 and	 rcx, rax
  004e2	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  004e6	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004e9	8b c8		 mov	 ecx, eax
  004eb	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  004ee	c1 e9 08	 shr	 ecx, 8
  004f1	0f b6 c9	 movzx	 ecx, cl
  004f4	3b ce		 cmp	 ecx, esi
  004f6	76 5b		 jbe	 SHORT $LN369@inflateBac@3
$LL215@inflateBac@3:

; 403  :                     PULLBYTE();

  004f8	85 ff		 test	 edi, edi
  004fa	75 18		 jne	 SHORT $LN208@inflateBac@3
  004fc	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00500	49 8b cf	 mov	 rcx, r15
  00503	41 ff d4	 call	 r12
  00506	8b f8		 mov	 edi, eax
  00508	85 c0		 test	 eax, eax
  0050a	0f 84 18 09 00
	00		 je	 $LN363@inflateBac@3
  00510	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN208@inflateBac@3:
  00514	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00518	8b ce		 mov	 ecx, esi
  0051a	49 ff c2	 inc	 r10
  0051d	d3 e0		 shl	 eax, cl
  0051f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00523	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00525	44 03 e8	 add	 r13d, eax
  00528	b8 01 00 00 00	 mov	 eax, 1
  0052d	83 c6 08	 add	 esi, 8
  00530	d3 e0		 shl	 eax, cl
  00532	ff cf		 dec	 edi
  00534	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00537	41 8b c5	 mov	 eax, r13d
  0053a	48 23 c8	 and	 rcx, rax
  0053d	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00541	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00544	8b c8		 mov	 ecx, eax
  00546	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00549	c1 e9 08	 shr	 ecx, 8
  0054c	0f b6 c9	 movzx	 ecx, cl
  0054f	3b ce		 cmp	 ecx, esi
  00551	77 a5		 ja	 SHORT $LL215@inflateBac@3
$LN369@inflateBac@3:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  00553	8b d0		 mov	 edx, eax
  00555	c1 ea 10	 shr	 edx, 16
  00558	66 83 fa 10	 cmp	 dx, 16
  0055c	73 25		 jae	 SHORT $LN431@inflateBac@3

; 406  :                     DROPBITS(here.bits);

  0055e	c1 e8 08	 shr	 eax, 8
  00561	0f b6 c8	 movzx	 ecx, al

; 407  :                     state->lens[state->have++] = here.val;

  00564	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00568	66 41 89 94 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], dx
  00571	41 d3 ed	 shr	 r13d, cl
  00574	2b f1		 sub	 esi, ecx
  00576	41 ff 46 7c	 inc	 DWORD PTR [r14+124]

; 408  :                 }
; 409  :                 else {

  0057a	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0057e	e9 9b 01 00 00	 jmp	 $LN400@inflateBac@3
$LN431@inflateBac@3:

; 410  :                     if (here.val == 16) {

  00583	0f 85 8a 00 00
	00		 jne	 $LN199@inflateBac@3

; 411  :                         NEEDBITS(here.bits + 2);

  00589	0f b6 5d bd	 movzx	 ebx, BYTE PTR here$[rbp-119]
  0058d	c1 e8 08	 shr	 eax, 8
  00590	0f b6 c8	 movzx	 ecx, al
  00593	83 c1 02	 add	 ecx, 2
  00596	3b f1		 cmp	 esi, ecx
  00598	73 43		 jae	 SHORT $LN197@inflateBac@3
  0059a	66 0f 1f 44 00
	00		 npad	 6
$LL195@inflateBac@3:
  005a0	85 ff		 test	 edi, edi
  005a2	75 18		 jne	 SHORT $LN189@inflateBac@3
  005a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005a8	49 8b cf	 mov	 rcx, r15
  005ab	41 ff d4	 call	 r12
  005ae	8b f8		 mov	 edi, eax
  005b0	85 c0		 test	 eax, eax
  005b2	0f 84 70 08 00
	00		 je	 $LN363@inflateBac@3
  005b8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN189@inflateBac@3:
  005bc	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  005c0	8b ce		 mov	 ecx, esi
  005c2	49 ff c2	 inc	 r10
  005c5	d3 e0		 shl	 eax, cl
  005c7	83 c6 08	 add	 esi, 8
  005ca	ff cf		 dec	 edi
  005cc	44 03 e8	 add	 r13d, eax
  005cf	0f b6 c3	 movzx	 eax, bl
  005d2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  005d6	83 c0 02	 add	 eax, 2
  005d9	3b f0		 cmp	 esi, eax
  005db	72 c3		 jb	 SHORT $LL195@inflateBac@3
$LN197@inflateBac@3:

; 412  :                         DROPBITS(here.bits);
; 413  :                         if (state->have == 0) {

  005dd	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  005e1	0f b6 cb	 movzx	 ecx, bl
  005e4	41 d3 ed	 shr	 r13d, cl
  005e7	2b f1		 sub	 esi, ecx
  005e9	85 c0		 test	 eax, eax
  005eb	0f 84 60 01 00
	00		 je	 $LN374@inflateBac@3

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  005f1	45 8b c5	 mov	 r8d, r13d
  005f4	ff c8		 dec	 eax

; 420  :                         DROPBITS(2);

  005f6	41 c1 ed 02	 shr	 r13d, 2
  005fa	45 0f b7 8c 46
	88 00 00 00	 movzx	 r9d, WORD PTR [r14+rax*2+136]
  00603	41 83 e0 03	 and	 r8d, 3
  00607	41 83 c0 03	 add	 r8d, 3
  0060b	83 c6 fe	 add	 esi, -2			; fffffffeH

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  0060e	e9 ce 00 00 00	 jmp	 $LN138@inflateBac@3
$LN199@inflateBac@3:
  00613	66 83 7d be 11	 cmp	 WORD PTR here$[rbp-118], 17

; 423  :                         NEEDBITS(here.bits + 3);

  00618	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR here$[rbp-119]
  0061d	75 5c		 jne	 SHORT $LN156@inflateBac@3
  0061f	41 8d 5c 24 03	 lea	 ebx, DWORD PTR [r12+3]
  00624	3b f3		 cmp	 esi, ebx
  00626	73 37		 jae	 SHORT $LN175@inflateBac@3
$LL173@inflateBac@3:
  00628	85 ff		 test	 edi, edi
  0062a	75 18		 jne	 SHORT $LN167@inflateBac@3
  0062c	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00630	49 8b cf	 mov	 rcx, r15
  00633	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00636	8b f8		 mov	 edi, eax
  00638	85 c0		 test	 eax, eax
  0063a	0f 84 e8 07 00
	00		 je	 $LN363@inflateBac@3
  00640	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN167@inflateBac@3:
  00644	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00648	8b ce		 mov	 ecx, esi
  0064a	49 ff c2	 inc	 r10
  0064d	d3 e0		 shl	 eax, cl
  0064f	83 c6 08	 add	 esi, 8
  00652	ff cf		 dec	 edi
  00654	44 03 e8	 add	 r13d, eax
  00657	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0065b	3b f3		 cmp	 esi, ebx
  0065d	72 c9		 jb	 SHORT $LL173@inflateBac@3
$LN175@inflateBac@3:

; 424  :                         DROPBITS(here.bits);

  0065f	41 8b cc	 mov	 ecx, r12d

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  00662	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00667	41 d3 ed	 shr	 r13d, cl
  0066a	45 8b c5	 mov	 r8d, r13d
  0066d	41 83 e0 07	 and	 r8d, 7
  00671	41 83 c0 03	 add	 r8d, 3
  00675	41 c1 ed 03	 shr	 r13d, 3

; 428  :                     }
; 429  :                     else {

  00679	eb 5a		 jmp	 SHORT $LN432@inflateBac@3
$LN156@inflateBac@3:

; 430  :                         NEEDBITS(here.bits + 7);

  0067b	41 8d 5c 24 07	 lea	 ebx, DWORD PTR [r12+7]
  00680	3b f3		 cmp	 esi, ebx
  00682	73 37		 jae	 SHORT $LN155@inflateBac@3
$LL153@inflateBac@3:
  00684	85 ff		 test	 edi, edi
  00686	75 18		 jne	 SHORT $LN147@inflateBac@3
  00688	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0068c	49 8b cf	 mov	 rcx, r15
  0068f	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00692	8b f8		 mov	 edi, eax
  00694	85 c0		 test	 eax, eax
  00696	0f 84 8c 07 00
	00		 je	 $LN363@inflateBac@3
  0069c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN147@inflateBac@3:
  006a0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  006a4	8b ce		 mov	 ecx, esi
  006a6	49 ff c2	 inc	 r10
  006a9	d3 e0		 shl	 eax, cl
  006ab	83 c6 08	 add	 esi, 8
  006ae	ff cf		 dec	 edi
  006b0	44 03 e8	 add	 r13d, eax
  006b3	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  006b7	3b f3		 cmp	 esi, ebx
  006b9	72 c9		 jb	 SHORT $LL153@inflateBac@3
$LN155@inflateBac@3:

; 431  :                         DROPBITS(here.bits);

  006bb	41 8b cc	 mov	 ecx, r12d

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006be	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006c3	41 d3 ed	 shr	 r13d, cl
  006c6	45 8b c5	 mov	 r8d, r13d
  006c9	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  006cd	41 83 c0 0b	 add	 r8d, 11
  006d1	41 c1 ed 07	 shr	 r13d, 7
$LN432@inflateBac@3:
  006d5	41 2b c4	 sub	 eax, r12d
  006d8	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  006dc	45 33 c9	 xor	 r9d, r9d
  006df	03 f0		 add	 esi, eax
$LN138@inflateBac@3:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  006e1	41 8b 56 78	 mov	 edx, DWORD PTR [r14+120]
  006e5	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  006e9	41 03 56 74	 add	 edx, DWORD PTR [r14+116]
  006ed	41 8d 0c 00	 lea	 ecx, DWORD PTR [r8+rax]
  006f1	3b ca		 cmp	 ecx, edx
  006f3	77 5c		 ja	 SHORT $LN374@inflateBac@3

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  006f5	45 85 c0	 test	 r8d, r8d
  006f8	74 20		 je	 SHORT $LN426@inflateBac@3
  006fa	66 0f 1f 44 00
	00		 npad	 6
$LL136@inflateBac@3:

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00700	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00704	66 45 89 8c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], r9w
  0070d	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00711	41 ff c8	 dec	 r8d
  00714	75 ea		 jne	 SHORT $LL136@inflateBac@3

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  00716	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN426@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  0071a	49 8d 5e 68	 lea	 rbx, QWORD PTR [r14+104]
$LN400@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0071e	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00722	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00726	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  0072a	0f 82 a0 fd ff
	ff		 jb	 $LL217@inflateBac@3
$LN216@inflateBac@3:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00730	41 83 3e 1d	 cmp	 DWORD PTR [r14], 29
  00734	0f 84 6e 03 00
	00		 je	 $LN427@inflateBac@3

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  0073a	66 41 83 be 88
	02 00 00 00	 cmp	 WORD PTR [r14+648], 0
  00743	75 24		 jne	 SHORT $LN133@inflateBac@3

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00745	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;
; 453  :                 break;

  0074c	e9 40 fd ff ff	 jmp	 $LN439@inflateBac@3
$LN374@inflateBac@3:

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00751	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 415  :                             state->mode = BAD;
; 416  :                             break;

  00755	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00759	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0075d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00764	e9 42 01 00 00	 jmp	 $LN434@inflateBac@3
$LN133@inflateBac@3:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;
; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;
; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00769	45 8b 46 74	 mov	 r8d, DWORD PTR [r14+116]
  0076d	49 8d 86 48 05
	00 00		 lea	 rax, QWORD PTR [r14+1352]
  00774	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  0077b	49 89 86 80 00
	00 00		 mov	 QWORD PTR [r14+128], rax
  00782	49 89 46 58	 mov	 QWORD PTR [r14+88], rax
  00786	49 8d 86 08 03
	00 00		 lea	 rax, QWORD PTR [r14+776]
  0078d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00792	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00799	b9 01 00 00 00	 mov	 ecx, 1
  0079e	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  007a3	c7 03 09 00 00
	00		 mov	 DWORD PTR [rbx], 9
  007a9	e8 00 00 00 00	 call	 inflate_table

; 464  :             if (ret) {

  007ae	85 c0		 test	 eax, eax
  007b0	74 0c		 je	 SHORT $LN132@inflateBac@3

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  007b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;
; 467  :                 break;

  007b9	e9 d3 fc ff ff	 jmp	 $LN439@inflateBac@3
$LN132@inflateBac@3:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  007be	49 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [r14+128]

; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  007c5	45 8b 46 78	 mov	 r8d, DWORD PTR [r14+120]
  007c9	49 8d 4e 6c	 lea	 rcx, QWORD PTR [r14+108]
  007cd	49 89 46 60	 mov	 QWORD PTR [r14+96], rax

; 473  :             if (ret) {

  007d1	41 8b 46 74	 mov	 eax, DWORD PTR [r14+116]
  007d5	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  007db	49 8d 94 46 88
	00 00 00	 lea	 rdx, QWORD PTR [r14+rax*2+136]
  007e3	49 8d 86 08 03
	00 00		 lea	 rax, QWORD PTR [r14+776]
  007ea	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  007f1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007f6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007fb	b9 02 00 00 00	 mov	 ecx, 2
  00800	e8 00 00 00 00	 call	 inflate_table

; 474  :                 strm->msg = (char *)"invalid distances set";

  00805	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 475  :                 state->mode = BAD;
; 476  :                 break;

  00809	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  0080d	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00811	85 c0		 test	 eax, eax
  00813	74 0c		 je	 SHORT $LN131@inflateBac@3

; 474  :                 strm->msg = (char *)"invalid distances set";

  00815	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;
; 476  :                 break;

  0081c	e9 8a 00 00 00	 jmp	 $LN434@inflateBac@3
$LN131@inflateBac@3:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00821	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20
  00828	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0082c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN130@inflateBac@3:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00832	83 ff 06	 cmp	 edi, 6
  00835	0f 82 86 00 00
	00		 jb	 $LN353@inflateBac@3
  0083b	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00842	72 7d		 jb	 SHORT $LN353@inflateBac@3

; 484  :                 RESTORE();

  00844	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  00848	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  0084c	4d 89 10	 mov	 QWORD PTR [r8], r10
  0084f	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 485  :                 if (state->whave < state->wsize)

  00853	41 8b 56 2c	 mov	 edx, DWORD PTR [r14+44]
  00857	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  0085b	41 89 76 44	 mov	 DWORD PTR [r14+68], esi
  0085f	41 39 56 30	 cmp	 DWORD PTR [r14+48], edx
  00863	73 09		 jae	 SHORT $LN125@inflateBac@3

; 486  :                     state->whave = state->wsize - left;

  00865	8b c2		 mov	 eax, edx
  00867	41 2b c1	 sub	 eax, r9d
  0086a	41 89 46 30	 mov	 DWORD PTR [r14+48], eax
$LN125@inflateBac@3:

; 487  :                 inflate_fast(strm, state->wsize);

  0086e	49 8b c8	 mov	 rcx, r8
  00871	e8 00 00 00 00	 call	 inflate_fast

; 488  :                 LOAD();

  00876	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  0087a	33 d2		 xor	 edx, edx
  0087c	4d 8b 10	 mov	 r10, QWORD PTR [r8]
  0087f	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  00883	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  00887	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  0088b	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0088f	45 8b 6e 40	 mov	 r13d, DWORD PTR [r14+64]
  00893	41 8b 76 44	 mov	 esi, DWORD PTR [r14+68]
  00897	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0089b	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  0089f	e9 12 02 00 00	 jmp	 $LN387@inflateBac@3
$LN239@inflateBac@3:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  008a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
$LN434@inflateBac@3:
  008ab	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 370  :                 state->mode = BAD;

  008af	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 371  :                 break;

  008b6	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  008ba	33 d2		 xor	 edx, edx
  008bc	e9 f5 01 00 00	 jmp	 $LN387@inflateBac@3
$LN353@inflateBac@3:

; 489  :                 break;
; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  008c1	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  008c5	41 8b c3	 mov	 eax, r11d
  008c8	d3 e0		 shl	 eax, cl
  008ca	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  008cd	41 8b c5	 mov	 eax, r13d
  008d0	48 23 c8	 and	 rcx, rax
  008d3	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  008d7	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  008da	8b c8		 mov	 ecx, eax
  008dc	c1 e9 08	 shr	 ecx, 8
  008df	0f b6 c9	 movzx	 ecx, cl
  008e2	3b ce		 cmp	 ecx, esi
  008e4	76 5e		 jbe	 SHORT $LN376@inflateBac@3
$LL121@inflateBac@3:

; 496  :                 PULLBYTE();

  008e6	85 ff		 test	 edi, edi
  008e8	75 1e		 jne	 SHORT $LN114@inflateBac@3
  008ea	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  008ee	49 8b cf	 mov	 rcx, r15
  008f1	41 ff d4	 call	 r12
  008f4	8b f8		 mov	 edi, eax
  008f6	85 c0		 test	 eax, eax
  008f8	0f 84 2a 05 00
	00		 je	 $LN363@inflateBac@3
  008fe	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00902	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN114@inflateBac@3:
  00908	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  0090c	8b ce		 mov	 ecx, esi
  0090e	49 ff c2	 inc	 r10
  00911	d3 e0		 shl	 eax, cl
  00913	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00917	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  0091b	44 03 e8	 add	 r13d, eax
  0091e	41 8b c3	 mov	 eax, r11d
  00921	83 c6 08	 add	 esi, 8
  00924	d3 e0		 shl	 eax, cl
  00926	ff cf		 dec	 edi
  00928	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0092b	41 8b c5	 mov	 eax, r13d
  0092e	48 23 c8	 and	 rcx, rax
  00931	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00935	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00938	8b c8		 mov	 ecx, eax
  0093a	c1 e9 08	 shr	 ecx, 8
  0093d	0f b6 c9	 movzx	 ecx, cl
  00940	3b ce		 cmp	 ecx, esi
  00942	77 a2		 ja	 SHORT $LL121@inflateBac@3
$LN376@inflateBac@3:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00944	84 c0		 test	 al, al
  00946	0f 84 d4 00 00
	00		 je	 $LN96@inflateBac@3
  0094c	a8 f0		 test	 al, 240			; 000000f0H
  0094e	0f 85 cc 00 00
	00		 jne	 $LN96@inflateBac@3

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  00954	44 8b c8	 mov	 r9d, eax
  00957	0f b6 c8	 movzx	 ecx, al
  0095a	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0095d	44 0f b6 7d bd	 movzx	 r15d, BYTE PTR last$[rbp-119]
  00962	41 c1 e9 08	 shr	 r9d, 8
  00966	8b d8		 mov	 ebx, eax
  00968	c1 e8 10	 shr	 eax, 16
  0096b	41 0f b6 d1	 movzx	 edx, r9b
  0096f	45 8b c3	 mov	 r8d, r11d
  00972	03 ca		 add	 ecx, edx
  00974	41 d3 e0	 shl	 r8d, cl
  00977	8b ca		 mov	 ecx, edx
  00979	41 ff c8	 dec	 r8d
  0097c	45 23 c5	 and	 r8d, r13d
  0097f	41 d3 e8	 shr	 r8d, cl
  00982	44 03 c0	 add	 r8d, eax
  00985	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00989	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0098d	8b c8		 mov	 ecx, eax
  0098f	c1 e9 08	 shr	 ecx, 8
  00992	0f b6 d1	 movzx	 edx, cl
  00995	41 0f b6 c9	 movzx	 ecx, r9b
  00999	03 d1		 add	 edx, ecx
  0099b	3b d6		 cmp	 edx, esi
  0099d	76 74		 jbe	 SHORT $LN98@inflateBac@3
  0099f	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
$LL109@inflateBac@3:

; 504  :                     PULLBYTE();

  009a4	85 ff		 test	 edi, edi
  009a6	75 1f		 jne	 SHORT $LN102@inflateBac@3
  009a8	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009ac	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009b0	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009b3	8b f8		 mov	 edi, eax
  009b5	85 c0		 test	 eax, eax
  009b7	0f 84 6b 04 00
	00		 je	 $LN363@inflateBac@3
  009bd	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  009c1	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN102@inflateBac@3:
  009c7	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  009cb	8b ce		 mov	 ecx, esi
  009cd	45 0f b6 c7	 movzx	 r8d, r15b
  009d1	d3 e0		 shl	 eax, cl
  009d3	41 8b d3	 mov	 edx, r11d
  009d6	49 ff c2	 inc	 r10
  009d9	44 03 e8	 add	 r13d, eax
  009dc	41 0f b7 c4	 movzx	 eax, r12w
  009e0	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  009e4	0f b6 cb	 movzx	 ecx, bl
  009e7	83 c6 08	 add	 esi, 8
  009ea	ff cf		 dec	 edi
  009ec	41 03 c8	 add	 ecx, r8d
  009ef	d3 e2		 shl	 edx, cl
  009f1	41 8b c8	 mov	 ecx, r8d
  009f4	ff ca		 dec	 edx
  009f6	41 23 d5	 and	 edx, r13d
  009f9	d3 ea		 shr	 edx, cl
  009fb	03 d0		 add	 edx, eax
  009fd	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00a01	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a04	8b c8		 mov	 ecx, eax
  00a06	c1 e9 08	 shr	 ecx, 8
  00a09	0f b6 d1	 movzx	 edx, cl
  00a0c	41 03 d0	 add	 edx, r8d
  00a0f	3b d6		 cmp	 edx, esi
  00a11	77 91		 ja	 SHORT $LL109@inflateBac@3
$LN98@inflateBac@3:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  00a13	41 0f b6 cf	 movzx	 ecx, r15b
  00a17	4c 8b 7d 38	 mov	 r15, QWORD PTR in_desc$[rbp-120]
  00a1b	41 d3 ed	 shr	 r13d, cl
  00a1e	2b f1		 sub	 esi, ecx
$LN96@inflateBac@3:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00a20	8b c8		 mov	 ecx, eax
  00a22	c1 e9 08	 shr	 ecx, 8
  00a25	0f b6 c9	 movzx	 ecx, cl
  00a28	41 d3 ed	 shr	 r13d, cl
  00a2b	2b f1		 sub	 esi, ecx

; 509  :             state->length = (unsigned)here.val;

  00a2d	8b c8		 mov	 ecx, eax
  00a2f	c1 e9 10	 shr	 ecx, 16
  00a32	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00a36	84 c0		 test	 al, al
  00a38	75 5f		 jne	 SHORT $LN92@inflateBac@3

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00a3a	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a3e	45 85 e4	 test	 r12d, r12d
  00a41	75 2c		 jne	 SHORT $LN428@inflateBac@3
  00a43	45 8b 66 2c	 mov	 r12d, DWORD PTR [r14+44]
  00a47	49 8b 5e 38	 mov	 rbx, QWORD PTR [r14+56]
  00a4b	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a4f	45 8b c4	 mov	 r8d, r12d
  00a52	48 8b d3	 mov	 rdx, rbx
  00a55	45 89 66 30	 mov	 DWORD PTR [r14+48], r12d
  00a59	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00a5c	85 c0		 test	 eax, eax
  00a5e	74 13		 je	 SHORT $LN90@inflateBac@3
$LN366@inflateBac@3:

; 344  :                 ROOM();

  00a60	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00a64	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00a6a	e9 02 04 00 00	 jmp	 $inf_leave$81134
$LN428@inflateBac@3:

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00a6f	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN90@inflateBac@3:

; 517  :                 *put++ = (unsigned char)(state->length);

  00a73	41 0f b6 46 48	 movzx	 eax, BYTE PTR [r14+72]
  00a78	48 ff c3	 inc	 rbx

; 518  :                 left--;

  00a7b	41 ff cc	 dec	 r12d
  00a7e	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 519  :                 state->mode = LEN;

  00a81	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 520  :                 break;

  00a88	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00a8c	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00a90	45 8b cc	 mov	 r9d, r12d
  00a93	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00a97	eb 17		 jmp	 SHORT $LN433@inflateBac@3
$LN92@inflateBac@3:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00a99	a8 20		 test	 al, 32			; 00000020H
  00a9b	74 35		 je	 SHORT $LN86@inflateBac@3

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00a9d	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11

; 527  :                 break;

  00aa4	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN427@inflateBac@3:

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00aa8	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00aac	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN433@inflateBac@3:
  00ab0	33 d2		 xor	 edx, edx
$LN430@inflateBac@3:
  00ab2	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN387@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00ab6	41 8b 06	 mov	 eax, DWORD PTR [r14]
  00ab9	83 e8 0b	 sub	 eax, 11
  00abc	83 f8 12	 cmp	 eax, 18
  00abf	0f 87 a6 03 00
	00		 ja	 $LN1@inflateBac@3
  00ac5	4c 8b 7d 38	 mov	 r15, QWORD PTR in_desc$[rbp-120]
  00ac9	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00acd	e9 c6 f5 ff ff	 jmp	 $LN437@inflateBac@3
$LN86@inflateBac@3:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00ad2	a8 40		 test	 al, 64			; 00000040H
  00ad4	74 18		 je	 SHORT $LN85@inflateBac@3

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00ad6	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 533  :                 state->mode = BAD;
; 534  :                 break;

  00ada	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ade	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00ae2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00ae9	e9 bd fd ff ff	 jmp	 $LN434@inflateBac@3
$LN85@inflateBac@3:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00aee	0f b6 c8	 movzx	 ecx, al
  00af1	83 e1 0f	 and	 ecx, 15
  00af4	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx

; 539  :             if (state->extra != 0) {

  00af8	74 5d		 je	 SHORT $LN68@inflateBac@3

; 540  :                 NEEDBITS(state->extra);

  00afa	3b f1		 cmp	 esi, ecx
  00afc	73 42		 jae	 SHORT $LN82@inflateBac@3
  00afe	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL80@inflateBac@3:
  00b02	85 ff		 test	 edi, edi
  00b04	75 18		 jne	 SHORT $LN74@inflateBac@3
  00b06	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b0a	49 8b cf	 mov	 rcx, r15
  00b0d	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b10	8b f8		 mov	 edi, eax
  00b12	85 c0		 test	 eax, eax
  00b14	0f 84 0e 03 00
	00		 je	 $LN363@inflateBac@3
  00b1a	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN74@inflateBac@3:
  00b1e	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b21	8b ce		 mov	 ecx, esi
  00b23	48 ff c2	 inc	 rdx
  00b26	d3 e0		 shl	 eax, cl
  00b28	83 c6 08	 add	 esi, 8
  00b2b	ff cf		 dec	 edi
  00b2d	44 03 e8	 add	 r13d, eax
  00b30	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b34	41 3b 76 50	 cmp	 esi, DWORD PTR [r14+80]
  00b38	72 c8		 jb	 SHORT $LL80@inflateBac@3
  00b3a	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN82@inflateBac@3:

; 541  :                 state->length += BITS(state->extra);

  00b40	41 8b 4e 50	 mov	 ecx, DWORD PTR [r14+80]
  00b44	41 8b c3	 mov	 eax, r11d
  00b47	d3 e0		 shl	 eax, cl
  00b49	ff c8		 dec	 eax
  00b4b	41 23 c5	 and	 eax, r13d

; 542  :                 DROPBITS(state->extra);

  00b4e	41 d3 ed	 shr	 r13d, cl
  00b51	41 01 46 48	 add	 DWORD PTR [r14+72], eax
  00b55	2b f1		 sub	 esi, ecx
$LN68@inflateBac@3:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00b57	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00b5b	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b5f	41 8b c3	 mov	 eax, r11d
  00b62	d3 e0		 shl	 eax, cl
  00b64	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b67	41 8b c5	 mov	 eax, r13d
  00b6a	48 23 c8	 and	 rcx, rax
  00b6d	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00b71	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00b74	8b c8		 mov	 ecx, eax
  00b76	c1 e9 08	 shr	 ecx, 8
  00b79	0f b6 c9	 movzx	 ecx, cl
  00b7c	3b ce		 cmp	 ecx, esi
  00b7e	76 5e		 jbe	 SHORT $LN381@inflateBac@3
$LL67@inflateBac@3:

; 550  :                 PULLBYTE();

  00b80	85 ff		 test	 edi, edi
  00b82	75 1e		 jne	 SHORT $LN60@inflateBac@3
  00b84	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b88	49 8b cf	 mov	 rcx, r15
  00b8b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b8e	8b f8		 mov	 edi, eax
  00b90	85 c0		 test	 eax, eax
  00b92	0f 84 90 02 00
	00		 je	 $LN363@inflateBac@3
  00b98	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b9c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN60@inflateBac@3:
  00ba2	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00ba6	8b ce		 mov	 ecx, esi
  00ba8	49 ff c2	 inc	 r10
  00bab	d3 e0		 shl	 eax, cl
  00bad	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00bb1	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]
  00bb5	44 03 e8	 add	 r13d, eax
  00bb8	41 8b c3	 mov	 eax, r11d
  00bbb	83 c6 08	 add	 esi, 8
  00bbe	d3 e0		 shl	 eax, cl
  00bc0	ff cf		 dec	 edi
  00bc2	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bc5	41 8b c5	 mov	 eax, r13d
  00bc8	48 23 c8	 and	 rcx, rax
  00bcb	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00bcf	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bd2	8b c8		 mov	 ecx, eax
  00bd4	c1 e9 08	 shr	 ecx, 8
  00bd7	0f b6 c9	 movzx	 ecx, cl
  00bda	3b ce		 cmp	 ecx, esi
  00bdc	77 a2		 ja	 SHORT $LL67@inflateBac@3
$LN381@inflateBac@3:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00bde	a8 f0		 test	 al, 240			; 000000f0H
  00be0	0f 85 c8 00 00
	00		 jne	 $LN42@inflateBac@3

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00be6	44 8b c8	 mov	 r9d, eax
  00be9	0f b6 c8	 movzx	 ecx, al
  00bec	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bef	44 0f b6 7d bd	 movzx	 r15d, BYTE PTR last$[rbp-119]
  00bf4	41 c1 e9 08	 shr	 r9d, 8
  00bf8	8b d8		 mov	 ebx, eax
  00bfa	c1 e8 10	 shr	 eax, 16
  00bfd	41 0f b6 d1	 movzx	 edx, r9b
  00c01	45 8b c3	 mov	 r8d, r11d
  00c04	03 ca		 add	 ecx, edx
  00c06	41 d3 e0	 shl	 r8d, cl
  00c09	8b ca		 mov	 ecx, edx
  00c0b	41 ff c8	 dec	 r8d
  00c0e	45 23 c5	 and	 r8d, r13d
  00c11	41 d3 e8	 shr	 r8d, cl
  00c14	44 03 c0	 add	 r8d, eax
  00c17	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00c1b	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00c1f	8b c8		 mov	 ecx, eax
  00c21	c1 e9 08	 shr	 ecx, 8
  00c24	0f b6 d1	 movzx	 edx, cl
  00c27	41 0f b6 c9	 movzx	 ecx, r9b
  00c2b	03 d1		 add	 edx, ecx
  00c2d	3b d6		 cmp	 edx, esi
  00c2f	76 74		 jbe	 SHORT $LN44@inflateBac@3
  00c31	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
$LL55@inflateBac@3:

; 558  :                     PULLBYTE();

  00c36	85 ff		 test	 edi, edi
  00c38	75 1f		 jne	 SHORT $LN48@inflateBac@3
  00c3a	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c3e	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c42	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c45	8b f8		 mov	 edi, eax
  00c47	85 c0		 test	 eax, eax
  00c49	0f 84 d9 01 00
	00		 je	 $LN363@inflateBac@3
  00c4f	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c53	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN48@inflateBac@3:
  00c59	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c5d	8b ce		 mov	 ecx, esi
  00c5f	45 0f b6 c7	 movzx	 r8d, r15b
  00c63	d3 e0		 shl	 eax, cl
  00c65	41 8b d3	 mov	 edx, r11d
  00c68	49 ff c2	 inc	 r10
  00c6b	44 03 e8	 add	 r13d, eax
  00c6e	41 0f b7 c4	 movzx	 eax, r12w
  00c72	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00c76	0f b6 cb	 movzx	 ecx, bl
  00c79	83 c6 08	 add	 esi, 8
  00c7c	ff cf		 dec	 edi
  00c7e	41 03 c8	 add	 ecx, r8d
  00c81	d3 e2		 shl	 edx, cl
  00c83	41 8b c8	 mov	 ecx, r8d
  00c86	ff ca		 dec	 edx
  00c88	41 23 d5	 and	 edx, r13d
  00c8b	d3 ea		 shr	 edx, cl
  00c8d	03 d0		 add	 edx, eax
  00c8f	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00c93	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00c96	8b c8		 mov	 ecx, eax
  00c98	c1 e9 08	 shr	 ecx, 8
  00c9b	0f b6 d1	 movzx	 edx, cl
  00c9e	41 03 d0	 add	 edx, r8d
  00ca1	3b d6		 cmp	 edx, esi
  00ca3	77 91		 ja	 SHORT $LL55@inflateBac@3
$LN44@inflateBac@3:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00ca5	41 0f b6 cf	 movzx	 ecx, r15b
  00ca9	41 d3 ed	 shr	 r13d, cl
  00cac	2b f1		 sub	 esi, ecx
$LN42@inflateBac@3:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00cae	8b c8		 mov	 ecx, eax
  00cb0	c1 e9 08	 shr	 ecx, 8
  00cb3	0f b6 c9	 movzx	 ecx, cl
  00cb6	41 d3 ed	 shr	 r13d, cl
  00cb9	2b f1		 sub	 esi, ecx

; 563  :             if (here.op & 64) {

  00cbb	a8 40		 test	 al, 64			; 00000040H
  00cbd	74 18		 je	 SHORT $LN38@inflateBac@3

; 533  :                 state->mode = BAD;
; 534  :                 break;

  00cbf	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00cc3	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00cc7	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]

; 564  :                 strm->msg = (char *)"invalid distance code";

  00ccb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00cd2	e9 d4 fb ff ff	 jmp	 $LN434@inflateBac@3
$LN38@inflateBac@3:

; 565  :                 state->mode = BAD;
; 566  :                 break;
; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00cd7	8b c8		 mov	 ecx, eax
  00cd9	c1 e9 10	 shr	 ecx, 16
  00cdc	41 89 4e 4c	 mov	 DWORD PTR [r14+76], ecx

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00ce0	0f b6 c8	 movzx	 ecx, al
  00ce3	83 e1 0f	 and	 ecx, 15
  00ce6	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx

; 572  :             if (state->extra != 0) {

  00cea	74 5e		 je	 SHORT $LN21@inflateBac@3

; 573  :                 NEEDBITS(state->extra);

  00cec	3b f1		 cmp	 esi, ecx
  00cee	73 43		 jae	 SHORT $LN35@inflateBac@3
  00cf0	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL33@inflateBac@3:
  00cf4	85 ff		 test	 edi, edi
  00cf6	75 19		 jne	 SHORT $LN27@inflateBac@3
  00cf8	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cfc	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00d00	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00d03	8b f8		 mov	 edi, eax
  00d05	85 c0		 test	 eax, eax
  00d07	0f 84 1b 01 00
	00		 je	 $LN363@inflateBac@3
  00d0d	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN27@inflateBac@3:
  00d11	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d14	8b ce		 mov	 ecx, esi
  00d16	48 ff c2	 inc	 rdx
  00d19	d3 e0		 shl	 eax, cl
  00d1b	83 c6 08	 add	 esi, 8
  00d1e	ff cf		 dec	 edi
  00d20	44 03 e8	 add	 r13d, eax
  00d23	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d27	41 3b 76 50	 cmp	 esi, DWORD PTR [r14+80]
  00d2b	72 c7		 jb	 SHORT $LL33@inflateBac@3
  00d2d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN35@inflateBac@3:

; 574  :                 state->offset += BITS(state->extra);

  00d33	41 8b 4e 50	 mov	 ecx, DWORD PTR [r14+80]
  00d37	41 8b c3	 mov	 eax, r11d
  00d3a	d3 e0		 shl	 eax, cl
  00d3c	ff c8		 dec	 eax
  00d3e	41 23 c5	 and	 eax, r13d

; 575  :                 DROPBITS(state->extra);

  00d41	41 d3 ed	 shr	 r13d, cl
  00d44	41 01 46 4c	 add	 DWORD PTR [r14+76], eax
  00d48	2b f1		 sub	 esi, ecx
$LN21@inflateBac@3:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  00d4a	41 8b 4e 2c	 mov	 ecx, DWORD PTR [r14+44]
  00d4e	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d52	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d56	33 d2		 xor	 edx, edx
  00d58	41 39 4e 30	 cmp	 DWORD PTR [r14+48], ecx
  00d5c	8b c2		 mov	 eax, edx
  00d5e	41 0f 42 c4	 cmovb	 eax, r12d
  00d62	2b c8		 sub	 ecx, eax
  00d64	41 39 4e 4c	 cmp	 DWORD PTR [r14+76], ecx
  00d68	76 26		 jbe	 SHORT $LL19@inflateBac@3

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00d6a	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00d6e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d75	45 8b cc	 mov	 r9d, r12d
  00d78	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00d7c	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00d83	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00d87	e9 2a fd ff ff	 jmp	 $LN387@inflateBac@3
  00d8c	0f 1f 40 00	 npad	 4
$LL19@inflateBac@3:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00d90	45 85 e4	 test	 r12d, r12d
  00d93	75 21		 jne	 SHORT $LN15@inflateBac@3
  00d95	45 8b 66 2c	 mov	 r12d, DWORD PTR [r14+44]
  00d99	49 8b 5e 38	 mov	 rbx, QWORD PTR [r14+56]
  00d9d	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00da1	45 8b c4	 mov	 r8d, r12d
  00da4	48 8b d3	 mov	 rdx, rbx
  00da7	45 89 66 30	 mov	 DWORD PTR [r14+48], r12d
  00dab	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00dae	85 c0		 test	 eax, eax
  00db0	0f 85 aa fc ff
	ff		 jne	 $LN366@inflateBac@3
$LN15@inflateBac@3:

; 588  :                 copy = state->wsize - state->offset;

  00db6	41 8b 4e 4c	 mov	 ecx, DWORD PTR [r14+76]
  00dba	41 8b 46 2c	 mov	 eax, DWORD PTR [r14+44]
  00dbe	2b c1		 sub	 eax, ecx

; 589  :                 if (copy < left) {

  00dc0	41 3b c4	 cmp	 eax, r12d
  00dc3	73 0c		 jae	 SHORT $LN11@inflateBac@3

; 590  :                     from = put + copy;

  00dc5	8b d0		 mov	 edx, eax

; 591  :                     copy = left - copy;

  00dc7	41 8b cc	 mov	 ecx, r12d
  00dca	48 03 d3	 add	 rdx, rbx
  00dcd	2b c8		 sub	 ecx, eax

; 592  :                 }
; 593  :                 else {

  00dcf	eb 09		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 594  :                     from = put - state->offset;

  00dd1	48 8b d3	 mov	 rdx, rbx
  00dd4	48 2b d1	 sub	 rdx, rcx

; 595  :                     copy = left;

  00dd7	41 8b cc	 mov	 ecx, r12d
$LN10@inflateBac@3:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00dda	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]
  00dde	3b c8		 cmp	 ecx, eax
  00de0	0f 47 c8	 cmova	 ecx, eax

; 598  :                 state->length -= copy;

  00de3	2b c1		 sub	 eax, ecx

; 599  :                 left -= copy;

  00de5	44 2b e1	 sub	 r12d, ecx

; 602  :                 } while (--copy);

  00de8	48 2b d3	 sub	 rdx, rbx
  00deb	41 89 46 48	 mov	 DWORD PTR [r14+72], eax
  00def	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00df3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL8@inflateBac@3:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00e00	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00e04	48 ff c3	 inc	 rbx

; 602  :                 } while (--copy);

  00e07	ff c9		 dec	 ecx
  00e09	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  00e0c	75 f2		 jne	 SHORT $LL8@inflateBac@3

; 603  :             } while (state->length != 0);

  00e0e	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00e12	41 39 4e 48	 cmp	 DWORD PTR [r14+72], ecx
  00e16	0f 85 74 ff ff
	ff		 jne	 $LL19@inflateBac@3
  00e1c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e20	45 8b cc	 mov	 r9d, r12d
  00e23	e9 88 fc ff ff	 jmp	 $LN433@inflateBac@3
$LN363@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  00e28	45 33 d2	 xor	 r10d, r10d
$LN438@inflateBac@3:
  00e2b	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e31	eb 3e		 jmp	 SHORT $inf_leave$81134
$LN368@inflateBac@3:

; 379  :                 NEEDBITS(3);

  00e33	4c 8b d3	 mov	 r10, rbx
  00e36	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e3c	eb 33		 jmp	 SHORT $inf_leave$81134
$LN5@inflateBac@3:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00e3e	45 8b 46 2c	 mov	 r8d, DWORD PTR [r14+44]
  00e42	45 3b c8	 cmp	 r9d, r8d
  00e45	73 2a		 jae	 SHORT $inf_leave$81134

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00e47	49 8b 56 38	 mov	 rdx, QWORD PTR [r14+56]
  00e4b	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e4f	45 2b c1	 sub	 r8d, r9d
  00e52	ff 55 40	 call	 QWORD PTR out$[rbp-120]

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;

  00e55	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e59	85 c0		 test	 eax, eax
  00e5b	75 ce		 jne	 SHORT $LN438@inflateBac@3
  00e5d	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00e61	eb 0e		 jmp	 SHORT $inf_leave$81134
$LN2@inflateBac@3:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00e63	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 617  :             goto inf_leave;

  00e69	eb 06		 jmp	 SHORT $inf_leave$81134
$LN1@inflateBac@3:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00e6b	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$81134:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e71	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e75	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  00e7a	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e7f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 627  :     strm->avail_in = have;

  00e84	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00e87	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e8c	4c 89 10	 mov	 QWORD PTR [rax], r10

; 628  :     return ret;

  00e8f	41 8b c3	 mov	 eax, r11d

; 629  : }

  00e92	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e96	41 5f		 pop	 r15
  00e98	41 5e		 pop	 r14
  00e9a	41 5c		 pop	 r12
  00e9c	5d		 pop	 rbp
  00e9d	c3		 ret	 0
$LN333@inflateBac@3:

; 274  :         return Z_STREAM_ERROR;

  00e9e	b8 fe ff ff ff	 mov	 eax, -2

; 629  : }

  00ea3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00ea7	41 5f		 pop	 r15
  00ea9	41 5e		 pop	 r14
  00eab	41 5c		 pop	 r12
  00ead	5d		 pop	 rbp
  00eae	c3		 ret	 0
  00eaf	90		 npad	 1
$LN414@inflateBac@3:
  00eb0	00 00 00 00	 DD	 $LN328@inflateBac@3
  00eb4	00 00 00 00	 DD	 $LN1@inflateBac@3
  00eb8	00 00 00 00	 DD	 $LN297@inflateBac@3
  00ebc	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ec0	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ec4	00 00 00 00	 DD	 $LN262@inflateBac@3
  00ec8	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ecc	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ed0	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ed4	00 00 00 00	 DD	 $LN130@inflateBac@3
  00ed8	00 00 00 00	 DD	 $LN1@inflateBac@3
  00edc	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ee0	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ee4	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ee8	00 00 00 00	 DD	 $LN1@inflateBac@3
  00eec	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ef0	00 00 00 00	 DD	 $LN1@inflateBac@3
  00ef4	00 00 00 00	 DD	 $LN5@inflateBac@3
  00ef8	00 00 00 00	 DD	 $LN2@inflateBac@3
inflateBack ENDP
END
