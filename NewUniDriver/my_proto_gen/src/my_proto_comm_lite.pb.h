// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: my_proto_comm_lite.proto

#ifndef PROTOBUF_my_5fproto_5fcomm_5flite_2eproto__INCLUDED
#define PROTOBUF_my_5fproto_5fcomm_5flite_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "my_common_proto_comm_lite.pb.h"
// @@protoc_insertion_point(includes)

namespace my_comm_proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

class ClsLoginMD;
class CommPacket;
class PInspectionReportMediaFile;
class PInspectionReports;
class PMobileHB;
class PVehicleReports;

// ===================================================================

class PInspectionReportMediaFile : public ::google::protobuf::MessageLite {
 public:
  PInspectionReportMediaFile();
  virtual ~PInspectionReportMediaFile();

  PInspectionReportMediaFile(const PInspectionReportMediaFile& from);

  inline PInspectionReportMediaFile& operator=(const PInspectionReportMediaFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PInspectionReportMediaFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PInspectionReportMediaFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PInspectionReportMediaFile* other);

  // implements Message ----------------------------------------------

  inline PInspectionReportMediaFile* New() const { return New(NULL); }

  PInspectionReportMediaFile* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PInspectionReportMediaFile& from);
  void MergeFrom(const PInspectionReportMediaFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PInspectionReportMediaFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fname = 1;
  bool has_fname() const;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // required bytes payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:my_comm_proto.PInspectionReportMediaFile)
 private:
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static PInspectionReportMediaFile* default_instance_;
};
// -------------------------------------------------------------------

class PInspectionReports : public ::google::protobuf::MessageLite {
 public:
  PInspectionReports();
  virtual ~PInspectionReports();

  PInspectionReports(const PInspectionReports& from);

  inline PInspectionReports& operator=(const PInspectionReports& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PInspectionReports& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PInspectionReports* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PInspectionReports* other);

  // implements Message ----------------------------------------------

  inline PInspectionReports* New() const { return New(NULL); }

  PInspectionReports* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PInspectionReports& from);
  void MergeFrom(const PInspectionReports& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PInspectionReports* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .my_comm_proto.PInspectionRowList reports = 1;
  bool has_reports() const;
  void clear_reports();
  static const int kReportsFieldNumber = 1;
  const ::my_comm_proto::PInspectionRowList& reports() const;
  ::my_comm_proto::PInspectionRowList* mutable_reports();
  ::my_comm_proto::PInspectionRowList* release_reports();
  void set_allocated_reports(::my_comm_proto::PInspectionRowList* reports);

  // repeated .my_comm_proto.PInspectionReportMediaFile mfiles = 2;
  int mfiles_size() const;
  void clear_mfiles();
  static const int kMfilesFieldNumber = 2;
  const ::my_comm_proto::PInspectionReportMediaFile& mfiles(int index) const;
  ::my_comm_proto::PInspectionReportMediaFile* mutable_mfiles(int index);
  ::my_comm_proto::PInspectionReportMediaFile* add_mfiles();
  ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >*
      mutable_mfiles();
  const ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >&
      mfiles() const;

  // @@protoc_insertion_point(class_scope:my_comm_proto.PInspectionReports)
 private:
  inline void set_has_reports();
  inline void clear_has_reports();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::my_comm_proto::PInspectionRowList* reports_;
  ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile > mfiles_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static PInspectionReports* default_instance_;
};
// -------------------------------------------------------------------

class PVehicleReports : public ::google::protobuf::MessageLite {
 public:
  PVehicleReports();
  virtual ~PVehicleReports();

  PVehicleReports(const PVehicleReports& from);

  inline PVehicleReports& operator=(const PVehicleReports& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PVehicleReports& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVehicleReports* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVehicleReports* other);

  // implements Message ----------------------------------------------

  inline PVehicleReports* New() const { return New(NULL); }

  PVehicleReports* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVehicleReports& from);
  void MergeFrom(const PVehicleReports& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PVehicleReports* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .my_comm_proto.PBoxIdVehicleRowList vehicles = 1;
  bool has_vehicles() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 1;
  const ::my_comm_proto::PBoxIdVehicleRowList& vehicles() const;
  ::my_comm_proto::PBoxIdVehicleRowList* mutable_vehicles();
  ::my_comm_proto::PBoxIdVehicleRowList* release_vehicles();
  void set_allocated_vehicles(::my_comm_proto::PBoxIdVehicleRowList* vehicles);

  // repeated .my_comm_proto.PInspectionReportMediaFile mfiles = 2;
  int mfiles_size() const;
  void clear_mfiles();
  static const int kMfilesFieldNumber = 2;
  const ::my_comm_proto::PInspectionReportMediaFile& mfiles(int index) const;
  ::my_comm_proto::PInspectionReportMediaFile* mutable_mfiles(int index);
  ::my_comm_proto::PInspectionReportMediaFile* add_mfiles();
  ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >*
      mutable_mfiles();
  const ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >&
      mfiles() const;

  // @@protoc_insertion_point(class_scope:my_comm_proto.PVehicleReports)
 private:
  inline void set_has_vehicles();
  inline void clear_has_vehicles();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::my_comm_proto::PBoxIdVehicleRowList* vehicles_;
  ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile > mfiles_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static PVehicleReports* default_instance_;
};
// -------------------------------------------------------------------

class ClsLoginMD : public ::google::protobuf::MessageLite {
 public:
  ClsLoginMD();
  virtual ~ClsLoginMD();

  ClsLoginMD(const ClsLoginMD& from);

  inline ClsLoginMD& operator=(const ClsLoginMD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClsLoginMD& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClsLoginMD* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClsLoginMD* other);

  // implements Message ----------------------------------------------

  inline ClsLoginMD* New() const { return New(NULL); }

  ClsLoginMD* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClsLoginMD& from);
  void MergeFrom(const ClsLoginMD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClsLoginMD* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool res = 1;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 1;
  bool res() const;
  void set_res(bool value);

  // required int32 cid = 2;
  bool has_cid() const;
  void clear_cid();
  static const int kCidFieldNumber = 2;
  ::google::protobuf::int32 cid() const;
  void set_cid(::google::protobuf::int32 value);

  // required string user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string pass = 4;
  bool has_pass() const;
  void clear_pass();
  static const int kPassFieldNumber = 4;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // optional int32 ResourceID = 5;
  bool has_resourceid() const;
  void clear_resourceid();
  static const int kResourceIDFieldNumber = 5;
  ::google::protobuf::int32 resourceid() const;
  void set_resourceid(::google::protobuf::int32 value);

  // optional string DrName = 6;
  bool has_drname() const;
  void clear_drname();
  static const int kDrNameFieldNumber = 6;
  const ::std::string& drname() const;
  void set_drname(const ::std::string& value);
  void set_drname(const char* value);
  void set_drname(const char* value, size_t size);
  ::std::string* mutable_drname();
  ::std::string* release_drname();
  void set_allocated_drname(::std::string* drname);

  // optional .my_comm_proto.PBoxIdVehicleRowList vehicles = 7;
  bool has_vehicles() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 7;
  const ::my_comm_proto::PBoxIdVehicleRowList& vehicles() const;
  ::my_comm_proto::PBoxIdVehicleRowList* mutable_vehicles();
  ::my_comm_proto::PBoxIdVehicleRowList* release_vehicles();
  void set_allocated_vehicles(::my_comm_proto::PBoxIdVehicleRowList* vehicles);

  // optional .my_comm_proto.PConfiguration config = 8;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 8;
  const ::my_comm_proto::PConfiguration& config() const;
  ::my_comm_proto::PConfiguration* mutable_config();
  ::my_comm_proto::PConfiguration* release_config();
  void set_allocated_config(::my_comm_proto::PConfiguration* config);

  // optional .my_comm_proto.PEmployeeRow driverProf = 9;
  bool has_driverprof() const;
  void clear_driverprof();
  static const int kDriverProfFieldNumber = 9;
  const ::my_comm_proto::PEmployeeRow& driverprof() const;
  ::my_comm_proto::PEmployeeRow* mutable_driverprof();
  ::my_comm_proto::PEmployeeRow* release_driverprof();
  void set_allocated_driverprof(::my_comm_proto::PEmployeeRow* driverprof);

  // @@protoc_insertion_point(class_scope:my_comm_proto.ClsLoginMD)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_resourceid();
  inline void clear_has_resourceid();
  inline void set_has_drname();
  inline void clear_has_drname();
  inline void set_has_vehicles();
  inline void clear_has_vehicles();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_driverprof();
  inline void clear_has_driverprof();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool res_;
  ::google::protobuf::int32 cid_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  ::google::protobuf::internal::ArenaStringPtr drname_;
  ::my_comm_proto::PBoxIdVehicleRowList* vehicles_;
  ::my_comm_proto::PConfiguration* config_;
  ::my_comm_proto::PEmployeeRow* driverprof_;
  ::google::protobuf::int32 resourceid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static ClsLoginMD* default_instance_;
};
// -------------------------------------------------------------------

class PMobileHB : public ::google::protobuf::MessageLite {
 public:
  PMobileHB();
  virtual ~PMobileHB();

  PMobileHB(const PMobileHB& from);

  inline PMobileHB& operator=(const PMobileHB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PMobileHB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PMobileHB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PMobileHB* other);

  // implements Message ----------------------------------------------

  inline PMobileHB* New() const { return New(NULL); }

  PMobileHB* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PMobileHB& from);
  void MergeFrom(const PMobileHB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PMobileHB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rid = 1;
  bool has_rid() const;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  ::google::protobuf::int32 rid() const;
  void set_rid(::google::protobuf::int32 value);

  // required float lat = 2;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 2;
  float lat() const;
  void set_lat(float value);

  // required float lon = 3;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 3;
  float lon() const;
  void set_lon(float value);

  // required int32 spd = 4;
  bool has_spd() const;
  void clear_spd();
  static const int kSpdFieldNumber = 4;
  ::google::protobuf::int32 spd() const;
  void set_spd(::google::protobuf::int32 value);

  // required int32 cog = 5;
  bool has_cog() const;
  void clear_cog();
  static const int kCogFieldNumber = 5;
  ::google::protobuf::int32 cog() const;
  void set_cog(::google::protobuf::int32 value);

  // required int64 ts = 6;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 6;
  ::google::protobuf::int64 ts() const;
  void set_ts(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:my_comm_proto.PMobileHB)
 private:
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_spd();
  inline void clear_has_spd();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_ts();
  inline void clear_has_ts();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 rid_;
  float lat_;
  float lon_;
  ::google::protobuf::int32 spd_;
  ::google::protobuf::int64 ts_;
  ::google::protobuf::int32 cog_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static PMobileHB* default_instance_;
};
// -------------------------------------------------------------------

class CommPacket : public ::google::protobuf::MessageLite {
 public:
  CommPacket();
  virtual ~CommPacket();

  CommPacket(const CommPacket& from);

  inline CommPacket& operator=(const CommPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommPacket* other);

  // implements Message ----------------------------------------------

  inline CommPacket* New() const { return New(NULL); }

  CommPacket* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommPacket& from);
  void MergeFrom(const CommPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  ::google::protobuf::int32 req() const;
  void set_req(::google::protobuf::int32 value);

  // required int32 rID = 2;
  bool has_rid() const;
  void clear_rid();
  static const int kRIDFieldNumber = 2;
  ::google::protobuf::int32 rid() const;
  void set_rid(::google::protobuf::int32 value);

  // required int32 cID = 3;
  bool has_cid() const;
  void clear_cid();
  static const int kCIDFieldNumber = 3;
  ::google::protobuf::int32 cid() const;
  void set_cid(::google::protobuf::int32 value);

  // required string user = 4;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 4;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required bytes payload = 5;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:my_comm_proto.CommPacket)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 req_;
  ::google::protobuf::int32 rid_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::int32 cid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_my_5fproto_5fcomm_5flite_2eproto();
  #endif
  friend void protobuf_AssignDesc_my_5fproto_5fcomm_5flite_2eproto();
  friend void protobuf_ShutdownFile_my_5fproto_5fcomm_5flite_2eproto();

  void InitAsDefaultInstance();
  static CommPacket* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PInspectionReportMediaFile

// required string fname = 1;
inline bool PInspectionReportMediaFile::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PInspectionReportMediaFile::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PInspectionReportMediaFile::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PInspectionReportMediaFile::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fname();
}
inline const ::std::string& PInspectionReportMediaFile::fname() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PInspectionReportMediaFile.fname)
  return fname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PInspectionReportMediaFile::set_fname(const ::std::string& value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.PInspectionReportMediaFile.fname)
}
inline void PInspectionReportMediaFile::set_fname(const char* value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.PInspectionReportMediaFile.fname)
}
inline void PInspectionReportMediaFile::set_fname(const char* value, size_t size) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.PInspectionReportMediaFile.fname)
}
inline ::std::string* PInspectionReportMediaFile::mutable_fname() {
  set_has_fname();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PInspectionReportMediaFile.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PInspectionReportMediaFile::release_fname() {
  clear_has_fname();
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PInspectionReportMediaFile::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    set_has_fname();
  } else {
    clear_has_fname();
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.PInspectionReportMediaFile.fname)
}

// required bytes payload = 2;
inline bool PInspectionReportMediaFile::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PInspectionReportMediaFile::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PInspectionReportMediaFile::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PInspectionReportMediaFile::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& PInspectionReportMediaFile::payload() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PInspectionReportMediaFile.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PInspectionReportMediaFile::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.PInspectionReportMediaFile.payload)
}
inline void PInspectionReportMediaFile::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.PInspectionReportMediaFile.payload)
}
inline void PInspectionReportMediaFile::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.PInspectionReportMediaFile.payload)
}
inline ::std::string* PInspectionReportMediaFile::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PInspectionReportMediaFile.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PInspectionReportMediaFile::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PInspectionReportMediaFile::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.PInspectionReportMediaFile.payload)
}

// -------------------------------------------------------------------

// PInspectionReports

// required .my_comm_proto.PInspectionRowList reports = 1;
inline bool PInspectionReports::has_reports() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PInspectionReports::set_has_reports() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PInspectionReports::clear_has_reports() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PInspectionReports::clear_reports() {
  if (reports_ != NULL) reports_->::my_comm_proto::PInspectionRowList::Clear();
  clear_has_reports();
}
inline const ::my_comm_proto::PInspectionRowList& PInspectionReports::reports() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PInspectionReports.reports)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reports_ != NULL ? *reports_ : *default_instance().reports_;
#else
  return reports_ != NULL ? *reports_ : *default_instance_->reports_;
#endif
}
inline ::my_comm_proto::PInspectionRowList* PInspectionReports::mutable_reports() {
  set_has_reports();
  if (reports_ == NULL) {
    reports_ = new ::my_comm_proto::PInspectionRowList;
  }
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PInspectionReports.reports)
  return reports_;
}
inline ::my_comm_proto::PInspectionRowList* PInspectionReports::release_reports() {
  clear_has_reports();
  ::my_comm_proto::PInspectionRowList* temp = reports_;
  reports_ = NULL;
  return temp;
}
inline void PInspectionReports::set_allocated_reports(::my_comm_proto::PInspectionRowList* reports) {
  delete reports_;
  reports_ = reports;
  if (reports) {
    set_has_reports();
  } else {
    clear_has_reports();
  }
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.PInspectionReports.reports)
}

// repeated .my_comm_proto.PInspectionReportMediaFile mfiles = 2;
inline int PInspectionReports::mfiles_size() const {
  return mfiles_.size();
}
inline void PInspectionReports::clear_mfiles() {
  mfiles_.Clear();
}
inline const ::my_comm_proto::PInspectionReportMediaFile& PInspectionReports::mfiles(int index) const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PInspectionReports.mfiles)
  return mfiles_.Get(index);
}
inline ::my_comm_proto::PInspectionReportMediaFile* PInspectionReports::mutable_mfiles(int index) {
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PInspectionReports.mfiles)
  return mfiles_.Mutable(index);
}
inline ::my_comm_proto::PInspectionReportMediaFile* PInspectionReports::add_mfiles() {
  // @@protoc_insertion_point(field_add:my_comm_proto.PInspectionReports.mfiles)
  return mfiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >*
PInspectionReports::mutable_mfiles() {
  // @@protoc_insertion_point(field_mutable_list:my_comm_proto.PInspectionReports.mfiles)
  return &mfiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >&
PInspectionReports::mfiles() const {
  // @@protoc_insertion_point(field_list:my_comm_proto.PInspectionReports.mfiles)
  return mfiles_;
}

// -------------------------------------------------------------------

// PVehicleReports

// required .my_comm_proto.PBoxIdVehicleRowList vehicles = 1;
inline bool PVehicleReports::has_vehicles() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVehicleReports::set_has_vehicles() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVehicleReports::clear_has_vehicles() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVehicleReports::clear_vehicles() {
  if (vehicles_ != NULL) vehicles_->::my_comm_proto::PBoxIdVehicleRowList::Clear();
  clear_has_vehicles();
}
inline const ::my_comm_proto::PBoxIdVehicleRowList& PVehicleReports::vehicles() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PVehicleReports.vehicles)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicles_ != NULL ? *vehicles_ : *default_instance().vehicles_;
#else
  return vehicles_ != NULL ? *vehicles_ : *default_instance_->vehicles_;
#endif
}
inline ::my_comm_proto::PBoxIdVehicleRowList* PVehicleReports::mutable_vehicles() {
  set_has_vehicles();
  if (vehicles_ == NULL) {
    vehicles_ = new ::my_comm_proto::PBoxIdVehicleRowList;
  }
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PVehicleReports.vehicles)
  return vehicles_;
}
inline ::my_comm_proto::PBoxIdVehicleRowList* PVehicleReports::release_vehicles() {
  clear_has_vehicles();
  ::my_comm_proto::PBoxIdVehicleRowList* temp = vehicles_;
  vehicles_ = NULL;
  return temp;
}
inline void PVehicleReports::set_allocated_vehicles(::my_comm_proto::PBoxIdVehicleRowList* vehicles) {
  delete vehicles_;
  vehicles_ = vehicles;
  if (vehicles) {
    set_has_vehicles();
  } else {
    clear_has_vehicles();
  }
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.PVehicleReports.vehicles)
}

// repeated .my_comm_proto.PInspectionReportMediaFile mfiles = 2;
inline int PVehicleReports::mfiles_size() const {
  return mfiles_.size();
}
inline void PVehicleReports::clear_mfiles() {
  mfiles_.Clear();
}
inline const ::my_comm_proto::PInspectionReportMediaFile& PVehicleReports::mfiles(int index) const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PVehicleReports.mfiles)
  return mfiles_.Get(index);
}
inline ::my_comm_proto::PInspectionReportMediaFile* PVehicleReports::mutable_mfiles(int index) {
  // @@protoc_insertion_point(field_mutable:my_comm_proto.PVehicleReports.mfiles)
  return mfiles_.Mutable(index);
}
inline ::my_comm_proto::PInspectionReportMediaFile* PVehicleReports::add_mfiles() {
  // @@protoc_insertion_point(field_add:my_comm_proto.PVehicleReports.mfiles)
  return mfiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >*
PVehicleReports::mutable_mfiles() {
  // @@protoc_insertion_point(field_mutable_list:my_comm_proto.PVehicleReports.mfiles)
  return &mfiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::my_comm_proto::PInspectionReportMediaFile >&
PVehicleReports::mfiles() const {
  // @@protoc_insertion_point(field_list:my_comm_proto.PVehicleReports.mfiles)
  return mfiles_;
}

// -------------------------------------------------------------------

// ClsLoginMD

// required bool res = 1;
inline bool ClsLoginMD::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClsLoginMD::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClsLoginMD::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClsLoginMD::clear_res() {
  res_ = false;
  clear_has_res();
}
inline bool ClsLoginMD::res() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.res)
  return res_;
}
inline void ClsLoginMD::set_res(bool value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.res)
}

// required int32 cid = 2;
inline bool ClsLoginMD::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClsLoginMD::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClsLoginMD::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClsLoginMD::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
inline ::google::protobuf::int32 ClsLoginMD::cid() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.cid)
  return cid_;
}
inline void ClsLoginMD::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.cid)
}

// required string user = 3;
inline bool ClsLoginMD::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClsLoginMD::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClsLoginMD::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClsLoginMD::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ClsLoginMD::user() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.user)
}
inline void ClsLoginMD::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.ClsLoginMD.user)
}
inline void ClsLoginMD::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.ClsLoginMD.user)
}
inline ::std::string* ClsLoginMD::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClsLoginMD::release_user() {
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.user)
}

// required string pass = 4;
inline bool ClsLoginMD::has_pass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClsLoginMD::set_has_pass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClsLoginMD::clear_has_pass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClsLoginMD::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass();
}
inline const ::std::string& ClsLoginMD::pass() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.pass)
  return pass_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_pass(const ::std::string& value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.pass)
}
inline void ClsLoginMD::set_pass(const char* value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.ClsLoginMD.pass)
}
inline void ClsLoginMD::set_pass(const char* value, size_t size) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.ClsLoginMD.pass)
}
inline ::std::string* ClsLoginMD::mutable_pass() {
  set_has_pass();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClsLoginMD::release_pass() {
  clear_has_pass();
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    set_has_pass();
  } else {
    clear_has_pass();
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.pass)
}

// optional int32 ResourceID = 5;
inline bool ClsLoginMD::has_resourceid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClsLoginMD::set_has_resourceid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClsLoginMD::clear_has_resourceid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClsLoginMD::clear_resourceid() {
  resourceid_ = 0;
  clear_has_resourceid();
}
inline ::google::protobuf::int32 ClsLoginMD::resourceid() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.ResourceID)
  return resourceid_;
}
inline void ClsLoginMD::set_resourceid(::google::protobuf::int32 value) {
  set_has_resourceid();
  resourceid_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.ResourceID)
}

// optional string DrName = 6;
inline bool ClsLoginMD::has_drname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClsLoginMD::set_has_drname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClsLoginMD::clear_has_drname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClsLoginMD::clear_drname() {
  drname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_drname();
}
inline const ::std::string& ClsLoginMD::drname() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.DrName)
  return drname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_drname(const ::std::string& value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.ClsLoginMD.DrName)
}
inline void ClsLoginMD::set_drname(const char* value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.ClsLoginMD.DrName)
}
inline void ClsLoginMD::set_drname(const char* value, size_t size) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.ClsLoginMD.DrName)
}
inline ::std::string* ClsLoginMD::mutable_drname() {
  set_has_drname();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.DrName)
  return drname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClsLoginMD::release_drname() {
  clear_has_drname();
  return drname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_allocated_drname(::std::string* drname) {
  if (drname != NULL) {
    set_has_drname();
  } else {
    clear_has_drname();
  }
  drname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), drname);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.DrName)
}

// optional .my_comm_proto.PBoxIdVehicleRowList vehicles = 7;
inline bool ClsLoginMD::has_vehicles() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClsLoginMD::set_has_vehicles() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClsLoginMD::clear_has_vehicles() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClsLoginMD::clear_vehicles() {
  if (vehicles_ != NULL) vehicles_->::my_comm_proto::PBoxIdVehicleRowList::Clear();
  clear_has_vehicles();
}
inline const ::my_comm_proto::PBoxIdVehicleRowList& ClsLoginMD::vehicles() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.vehicles)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicles_ != NULL ? *vehicles_ : *default_instance().vehicles_;
#else
  return vehicles_ != NULL ? *vehicles_ : *default_instance_->vehicles_;
#endif
}
inline ::my_comm_proto::PBoxIdVehicleRowList* ClsLoginMD::mutable_vehicles() {
  set_has_vehicles();
  if (vehicles_ == NULL) {
    vehicles_ = new ::my_comm_proto::PBoxIdVehicleRowList;
  }
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.vehicles)
  return vehicles_;
}
inline ::my_comm_proto::PBoxIdVehicleRowList* ClsLoginMD::release_vehicles() {
  clear_has_vehicles();
  ::my_comm_proto::PBoxIdVehicleRowList* temp = vehicles_;
  vehicles_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_vehicles(::my_comm_proto::PBoxIdVehicleRowList* vehicles) {
  delete vehicles_;
  vehicles_ = vehicles;
  if (vehicles) {
    set_has_vehicles();
  } else {
    clear_has_vehicles();
  }
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.vehicles)
}

// optional .my_comm_proto.PConfiguration config = 8;
inline bool ClsLoginMD::has_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClsLoginMD::set_has_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClsLoginMD::clear_has_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClsLoginMD::clear_config() {
  if (config_ != NULL) config_->::my_comm_proto::PConfiguration::Clear();
  clear_has_config();
}
inline const ::my_comm_proto::PConfiguration& ClsLoginMD::config() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::my_comm_proto::PConfiguration* ClsLoginMD::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::my_comm_proto::PConfiguration;
  }
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.config)
  return config_;
}
inline ::my_comm_proto::PConfiguration* ClsLoginMD::release_config() {
  clear_has_config();
  ::my_comm_proto::PConfiguration* temp = config_;
  config_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_config(::my_comm_proto::PConfiguration* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.config)
}

// optional .my_comm_proto.PEmployeeRow driverProf = 9;
inline bool ClsLoginMD::has_driverprof() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClsLoginMD::set_has_driverprof() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClsLoginMD::clear_has_driverprof() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClsLoginMD::clear_driverprof() {
  if (driverprof_ != NULL) driverprof_->::my_comm_proto::PEmployeeRow::Clear();
  clear_has_driverprof();
}
inline const ::my_comm_proto::PEmployeeRow& ClsLoginMD::driverprof() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.ClsLoginMD.driverProf)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return driverprof_ != NULL ? *driverprof_ : *default_instance().driverprof_;
#else
  return driverprof_ != NULL ? *driverprof_ : *default_instance_->driverprof_;
#endif
}
inline ::my_comm_proto::PEmployeeRow* ClsLoginMD::mutable_driverprof() {
  set_has_driverprof();
  if (driverprof_ == NULL) {
    driverprof_ = new ::my_comm_proto::PEmployeeRow;
  }
  // @@protoc_insertion_point(field_mutable:my_comm_proto.ClsLoginMD.driverProf)
  return driverprof_;
}
inline ::my_comm_proto::PEmployeeRow* ClsLoginMD::release_driverprof() {
  clear_has_driverprof();
  ::my_comm_proto::PEmployeeRow* temp = driverprof_;
  driverprof_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_driverprof(::my_comm_proto::PEmployeeRow* driverprof) {
  delete driverprof_;
  driverprof_ = driverprof;
  if (driverprof) {
    set_has_driverprof();
  } else {
    clear_has_driverprof();
  }
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.ClsLoginMD.driverProf)
}

// -------------------------------------------------------------------

// PMobileHB

// required int32 rid = 1;
inline bool PMobileHB::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PMobileHB::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PMobileHB::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PMobileHB::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
inline ::google::protobuf::int32 PMobileHB::rid() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.rid)
  return rid_;
}
inline void PMobileHB::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.rid)
}

// required float lat = 2;
inline bool PMobileHB::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PMobileHB::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PMobileHB::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PMobileHB::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float PMobileHB::lat() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.lat)
  return lat_;
}
inline void PMobileHB::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.lat)
}

// required float lon = 3;
inline bool PMobileHB::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PMobileHB::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PMobileHB::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PMobileHB::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float PMobileHB::lon() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.lon)
  return lon_;
}
inline void PMobileHB::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.lon)
}

// required int32 spd = 4;
inline bool PMobileHB::has_spd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PMobileHB::set_has_spd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PMobileHB::clear_has_spd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PMobileHB::clear_spd() {
  spd_ = 0;
  clear_has_spd();
}
inline ::google::protobuf::int32 PMobileHB::spd() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.spd)
  return spd_;
}
inline void PMobileHB::set_spd(::google::protobuf::int32 value) {
  set_has_spd();
  spd_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.spd)
}

// required int32 cog = 5;
inline bool PMobileHB::has_cog() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PMobileHB::set_has_cog() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PMobileHB::clear_has_cog() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PMobileHB::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline ::google::protobuf::int32 PMobileHB::cog() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.cog)
  return cog_;
}
inline void PMobileHB::set_cog(::google::protobuf::int32 value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.cog)
}

// required int64 ts = 6;
inline bool PMobileHB::has_ts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PMobileHB::set_has_ts() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PMobileHB::clear_has_ts() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PMobileHB::clear_ts() {
  ts_ = GOOGLE_LONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::int64 PMobileHB::ts() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.PMobileHB.ts)
  return ts_;
}
inline void PMobileHB::set_ts(::google::protobuf::int64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.PMobileHB.ts)
}

// -------------------------------------------------------------------

// CommPacket

// required int32 req = 1;
inline bool CommPacket::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommPacket::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommPacket::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommPacket::clear_req() {
  req_ = 0;
  clear_has_req();
}
inline ::google::protobuf::int32 CommPacket::req() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.CommPacket.req)
  return req_;
}
inline void CommPacket::set_req(::google::protobuf::int32 value) {
  set_has_req();
  req_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.CommPacket.req)
}

// required int32 rID = 2;
inline bool CommPacket::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommPacket::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommPacket::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommPacket::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
inline ::google::protobuf::int32 CommPacket::rid() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.CommPacket.rID)
  return rid_;
}
inline void CommPacket::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.CommPacket.rID)
}

// required int32 cID = 3;
inline bool CommPacket::has_cid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommPacket::set_has_cid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommPacket::clear_has_cid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommPacket::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
inline ::google::protobuf::int32 CommPacket::cid() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.CommPacket.cID)
  return cid_;
}
inline void CommPacket::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
  // @@protoc_insertion_point(field_set:my_comm_proto.CommPacket.cID)
}

// required string user = 4;
inline bool CommPacket::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommPacket::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommPacket::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommPacket::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& CommPacket::user() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.CommPacket.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommPacket::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.CommPacket.user)
}
inline void CommPacket::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.CommPacket.user)
}
inline void CommPacket::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.CommPacket.user)
}
inline ::std::string* CommPacket::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.CommPacket.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommPacket::release_user() {
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommPacket::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.CommPacket.user)
}

// required bytes payload = 5;
inline bool CommPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommPacket::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& CommPacket::payload() const {
  // @@protoc_insertion_point(field_get:my_comm_proto.CommPacket.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:my_comm_proto.CommPacket.payload)
}
inline void CommPacket::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:my_comm_proto.CommPacket.payload)
}
inline void CommPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:my_comm_proto.CommPacket.payload)
}
inline ::std::string* CommPacket::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:my_comm_proto.CommPacket.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommPacket::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommPacket::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:my_comm_proto.CommPacket.payload)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace my_comm_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_my_5fproto_5fcomm_5flite_2eproto__INCLUDED
