// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flcnav_odb.proto

#ifndef PROTOBUF_flcnav_5fodb_2eproto__INCLUDED
#define PROTOBUF_flcnav_5fodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_flcnav_5fodb_2eproto();
void protobuf_AssignDesc_flcnav_5fodb_2eproto();
void protobuf_ShutdownFile_flcnav_5fodb_2eproto();

class FlcNavStructure;
class FlcNavTileBox;
class StringTable;
class IndexedStringTable;
class FlcNavMapIndex;
class FlcNavMapIndex_MapEncodingRule;
class FlcNavMapIndex_MapRootLevel;
class FlcNavMapIndex_MapDataBox;
class MapDataBlock;
class MapData;
class FlcNavAddressIndex;
class FlcNavAddressIndex_CitiesIndex;
class FlcNavAddressNameIndexData;
class FlcNavAddressNameIndexData_AddressNameIndexData;
class AddressNameIndexDataAtom;
class CityIndex;
class CityBlockIndex;
class StreetIndex;
class StreetIntersection;
class BuildingIndex;
class TransportRoutes;
class TransportRoute;
class TransportRouteStop;
class TransportStop;
class TransportStopsTree;
class FlcNavTransportIndex;
class FlcNavPoiIndex;
class FlcNavPoiNameIndex;
class FlcNavPoiNameIndex_FlcNavPoiNameIndexData;
class FlcNavPoiNameIndexDataAtom;
class FlcNavCategoryTable;
class FlcNavPoiBox;
class FlcNavPoiCategories;
class FlcNavPoiBoxData;
class FlcNavPoiBoxDataAtom;
class IdTable;
class RestrictionData;
class RouteData;
class FlcNavRoutingIndex;
class FlcNavRoutingIndex_RouteEncodingRule;
class FlcNavRoutingIndex_RouteDataBox;
class FlcNavRoutingIndex_RouteDataBlock;

// ===================================================================

class FlcNavStructure : public ::google::protobuf::Message {
 public:
  FlcNavStructure();
  virtual ~FlcNavStructure();
  
  FlcNavStructure(const FlcNavStructure& from);
  
  inline FlcNavStructure& operator=(const FlcNavStructure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavStructure& default_instance();
  
  void Swap(FlcNavStructure* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavStructure& from);
  void MergeFrom(const FlcNavStructure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // required int64 dateCreated = 18;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 18;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);
  
  // repeated .FlcNavAddressIndex addressIndex = 7;
  inline int addressindex_size() const;
  inline void clear_addressindex();
  static const int kAddressIndexFieldNumber = 7;
  inline const ::FlcNavAddressIndex& addressindex(int index) const;
  inline ::FlcNavAddressIndex* mutable_addressindex(int index);
  inline ::FlcNavAddressIndex* add_addressindex();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex >&
      addressindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex >*
      mutable_addressindex();
  
  // repeated .FlcNavTransportIndex transportIndex = 4;
  inline int transportindex_size() const;
  inline void clear_transportindex();
  static const int kTransportIndexFieldNumber = 4;
  inline const ::FlcNavTransportIndex& transportindex(int index) const;
  inline ::FlcNavTransportIndex* mutable_transportindex(int index);
  inline ::FlcNavTransportIndex* add_transportindex();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavTransportIndex >&
      transportindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavTransportIndex >*
      mutable_transportindex();
  
  // repeated .FlcNavPoiIndex poiIndex = 8;
  inline int poiindex_size() const;
  inline void clear_poiindex();
  static const int kPoiIndexFieldNumber = 8;
  inline const ::FlcNavPoiIndex& poiindex(int index) const;
  inline ::FlcNavPoiIndex* mutable_poiindex(int index);
  inline ::FlcNavPoiIndex* add_poiindex();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiIndex >&
      poiindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiIndex >*
      mutable_poiindex();
  
  // repeated .FlcNavMapIndex mapIndex = 6;
  inline int mapindex_size() const;
  inline void clear_mapindex();
  static const int kMapIndexFieldNumber = 6;
  inline const ::FlcNavMapIndex& mapindex(int index) const;
  inline ::FlcNavMapIndex* mutable_mapindex(int index);
  inline ::FlcNavMapIndex* add_mapindex();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex >&
      mapindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex >*
      mutable_mapindex();
  
  // repeated .FlcNavRoutingIndex routingIndex = 9;
  inline int routingindex_size() const;
  inline void clear_routingindex();
  static const int kRoutingIndexFieldNumber = 9;
  inline const ::FlcNavRoutingIndex& routingindex(int index) const;
  inline ::FlcNavRoutingIndex* mutable_routingindex(int index);
  inline ::FlcNavRoutingIndex* add_routingindex();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex >&
      routingindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex >*
      mutable_routingindex();
  
  // required uint32 versionConfirm = 32;
  inline bool has_versionconfirm() const;
  inline void clear_versionconfirm();
  static const int kVersionConfirmFieldNumber = 32;
  inline ::google::protobuf::uint32 versionconfirm() const;
  inline void set_versionconfirm(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavStructure)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 version_;
  ::google::protobuf::int64 datecreated_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex > addressindex_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavTransportIndex > transportindex_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiIndex > poiindex_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex > mapindex_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex > routingindex_;
  ::google::protobuf::uint32 versionconfirm_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavStructure* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavTileBox : public ::google::protobuf::Message {
 public:
  FlcNavTileBox();
  virtual ~FlcNavTileBox();
  
  FlcNavTileBox(const FlcNavTileBox& from);
  
  inline FlcNavTileBox& operator=(const FlcNavTileBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavTileBox& default_instance();
  
  void Swap(FlcNavTileBox* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavTileBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavTileBox& from);
  void MergeFrom(const FlcNavTileBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);
  
  // required uint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::uint32 right() const;
  inline void set_right(::google::protobuf::uint32 value);
  
  // required uint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::uint32 top() const;
  inline void set_top(::google::protobuf::uint32 value);
  
  // required uint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom() const;
  inline void set_bottom(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavTileBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 right_;
  ::google::protobuf::uint32 top_;
  ::google::protobuf::uint32 bottom_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavTileBox* default_instance_;
};
// -------------------------------------------------------------------

class StringTable : public ::google::protobuf::Message {
 public:
  StringTable();
  virtual ~StringTable();
  
  StringTable(const StringTable& from);
  
  inline StringTable& operator=(const StringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringTable& default_instance();
  
  void Swap(StringTable* other);
  
  // implements Message ----------------------------------------------
  
  StringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringTable& from);
  void MergeFrom(const StringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string s = 1;
  inline int s_size() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s(int index) const;
  inline ::std::string* mutable_s(int index);
  inline void set_s(int index, const ::std::string& value);
  inline void set_s(int index, const char* value);
  inline void set_s(int index, const char* value, size_t size);
  inline ::std::string* add_s();
  inline void add_s(const ::std::string& value);
  inline void add_s(const char* value);
  inline void add_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();
  
  // @@protoc_insertion_point(class_scope:StringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> s_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StringTable* default_instance_;
};
// -------------------------------------------------------------------

class IndexedStringTable : public ::google::protobuf::Message {
 public:
  IndexedStringTable();
  virtual ~IndexedStringTable();
  
  IndexedStringTable(const IndexedStringTable& from);
  
  inline IndexedStringTable& operator=(const IndexedStringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedStringTable& default_instance();
  
  void Swap(IndexedStringTable* other);
  
  // implements Message ----------------------------------------------
  
  IndexedStringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedStringTable& from);
  void MergeFrom(const IndexedStringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  
  // repeated string key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key(int index) const;
  inline ::std::string* mutable_key(int index);
  inline void set_key(int index, const ::std::string& value);
  inline void set_key(int index, const char* value);
  inline void set_key(int index, const char* value, size_t size);
  inline ::std::string* add_key();
  inline void add_key(const ::std::string& value);
  inline void add_key(const char* value);
  inline void add_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();
  
  // repeated fixed32 val = 4;
  inline int val_size() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::uint32 val(int index) const;
  inline void set_val(int index, ::google::protobuf::uint32 value);
  inline void add_val(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      val() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_val();
  
  // repeated .IndexedStringTable subtables = 5;
  inline int subtables_size() const;
  inline void clear_subtables();
  static const int kSubtablesFieldNumber = 5;
  inline const ::IndexedStringTable& subtables(int index) const;
  inline ::IndexedStringTable* mutable_subtables(int index);
  inline ::IndexedStringTable* add_subtables();
  inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
      subtables() const;
  inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
      mutable_subtables();
  
  // @@protoc_insertion_point(class_scope:IndexedStringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* prefix_;
  static const ::std::string _default_prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > val_;
  ::google::protobuf::RepeatedPtrField< ::IndexedStringTable > subtables_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IndexedStringTable* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavMapIndex_MapEncodingRule : public ::google::protobuf::Message {
 public:
  FlcNavMapIndex_MapEncodingRule();
  virtual ~FlcNavMapIndex_MapEncodingRule();
  
  FlcNavMapIndex_MapEncodingRule(const FlcNavMapIndex_MapEncodingRule& from);
  
  inline FlcNavMapIndex_MapEncodingRule& operator=(const FlcNavMapIndex_MapEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavMapIndex_MapEncodingRule& default_instance();
  
  void Swap(FlcNavMapIndex_MapEncodingRule* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavMapIndex_MapEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavMapIndex_MapEncodingRule& from);
  void MergeFrom(const FlcNavMapIndex_MapEncodingRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional uint32 id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 minZoom = 9;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 9;
  inline ::google::protobuf::uint32 minzoom() const;
  inline void set_minzoom(::google::protobuf::uint32 value);
  
  // optional uint32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavMapIndex.MapEncodingRule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 minzoom_;
  ::google::protobuf::uint32 type_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavMapIndex_MapEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavMapIndex_MapRootLevel : public ::google::protobuf::Message {
 public:
  FlcNavMapIndex_MapRootLevel();
  virtual ~FlcNavMapIndex_MapRootLevel();
  
  FlcNavMapIndex_MapRootLevel(const FlcNavMapIndex_MapRootLevel& from);
  
  inline FlcNavMapIndex_MapRootLevel& operator=(const FlcNavMapIndex_MapRootLevel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavMapIndex_MapRootLevel& default_instance();
  
  void Swap(FlcNavMapIndex_MapRootLevel* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavMapIndex_MapRootLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavMapIndex_MapRootLevel& from);
  void MergeFrom(const FlcNavMapIndex_MapRootLevel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 maxZoom = 1;
  inline bool has_maxzoom() const;
  inline void clear_maxzoom();
  static const int kMaxZoomFieldNumber = 1;
  inline ::google::protobuf::int32 maxzoom() const;
  inline void set_maxzoom(::google::protobuf::int32 value);
  
  // required int32 minZoom = 2;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 2;
  inline ::google::protobuf::int32 minzoom() const;
  inline void set_minzoom(::google::protobuf::int32 value);
  
  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required int32 top = 5;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 5;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required int32 bottom = 6;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 6;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .FlcNavMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::FlcNavMapIndex_MapDataBox& boxes(int index) const;
  inline ::FlcNavMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::FlcNavMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >*
      mutable_boxes();
  
  // repeated .MapDataBlock blocks = 15;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 15;
  inline const ::MapDataBlock& blocks(int index) const;
  inline ::MapDataBlock* mutable_blocks(int index);
  inline ::MapDataBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataBlock >*
      mutable_blocks();
  
  // @@protoc_insertion_point(class_scope:FlcNavMapIndex.MapRootLevel)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 maxzoom_;
  ::google::protobuf::int32 minzoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::MapDataBlock > blocks_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavMapIndex_MapRootLevel* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavMapIndex_MapDataBox : public ::google::protobuf::Message {
 public:
  FlcNavMapIndex_MapDataBox();
  virtual ~FlcNavMapIndex_MapDataBox();
  
  FlcNavMapIndex_MapDataBox(const FlcNavMapIndex_MapDataBox& from);
  
  inline FlcNavMapIndex_MapDataBox& operator=(const FlcNavMapIndex_MapDataBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavMapIndex_MapDataBox& default_instance();
  
  void Swap(FlcNavMapIndex_MapDataBox* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavMapIndex_MapDataBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavMapIndex_MapDataBox& from);
  void MergeFrom(const FlcNavMapIndex_MapDataBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // optional fixed32 shiftToMapData = 5;
  inline bool has_shifttomapdata() const;
  inline void clear_shifttomapdata();
  static const int kShiftToMapDataFieldNumber = 5;
  inline ::google::protobuf::uint32 shifttomapdata() const;
  inline void set_shifttomapdata(::google::protobuf::uint32 value);
  
  // optional bool ocean = 6;
  inline bool has_ocean() const;
  inline void clear_ocean();
  static const int kOceanFieldNumber = 6;
  inline bool ocean() const;
  inline void set_ocean(bool value);
  
  // repeated .FlcNavMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::FlcNavMapIndex_MapDataBox& boxes(int index) const;
  inline ::FlcNavMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::FlcNavMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >*
      mutable_boxes();
  
  // @@protoc_insertion_point(class_scope:FlcNavMapIndex.MapDataBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::uint32 shifttomapdata_;
  bool ocean_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox > boxes_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavMapIndex_MapDataBox* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavMapIndex : public ::google::protobuf::Message {
 public:
  FlcNavMapIndex();
  virtual ~FlcNavMapIndex();
  
  FlcNavMapIndex(const FlcNavMapIndex& from);
  
  inline FlcNavMapIndex& operator=(const FlcNavMapIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavMapIndex& default_instance();
  
  void Swap(FlcNavMapIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavMapIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavMapIndex& from);
  void MergeFrom(const FlcNavMapIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlcNavMapIndex_MapEncodingRule MapEncodingRule;
  typedef FlcNavMapIndex_MapRootLevel MapRootLevel;
  typedef FlcNavMapIndex_MapDataBox MapDataBox;
  
  // accessors -------------------------------------------------------
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .FlcNavMapIndex.MapEncodingRule rules = 4;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 4;
  inline const ::FlcNavMapIndex_MapEncodingRule& rules(int index) const;
  inline ::FlcNavMapIndex_MapEncodingRule* mutable_rules(int index);
  inline ::FlcNavMapIndex_MapEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapEncodingRule >*
      mutable_rules();
  
  // repeated .FlcNavMapIndex.MapRootLevel levels = 5;
  inline int levels_size() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 5;
  inline const ::FlcNavMapIndex_MapRootLevel& levels(int index) const;
  inline ::FlcNavMapIndex_MapRootLevel* mutable_levels(int index);
  inline ::FlcNavMapIndex_MapRootLevel* add_levels();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapRootLevel >&
      levels() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapRootLevel >*
      mutable_levels();
  
  // @@protoc_insertion_point(class_scope:FlcNavMapIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapEncodingRule > rules_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapRootLevel > levels_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavMapIndex* default_instance_;
};
// -------------------------------------------------------------------

class MapDataBlock : public ::google::protobuf::Message {
 public:
  MapDataBlock();
  virtual ~MapDataBlock();
  
  MapDataBlock(const MapDataBlock& from);
  
  inline MapDataBlock& operator=(const MapDataBlock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataBlock& default_instance();
  
  void Swap(MapDataBlock* other);
  
  // implements Message ----------------------------------------------
  
  MapDataBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataBlock& from);
  void MergeFrom(const MapDataBlock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 baseId = 10;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 10;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // repeated .MapData dataObjects = 12;
  inline int dataobjects_size() const;
  inline void clear_dataobjects();
  static const int kDataObjectsFieldNumber = 12;
  inline const ::MapData& dataobjects(int index) const;
  inline ::MapData* mutable_dataobjects(int index);
  inline ::MapData* add_dataobjects();
  inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
      dataobjects() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapData >*
      mutable_dataobjects();
  
  // optional .StringTable stringTable = 15;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 15;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:MapDataBlock)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 baseid_;
  ::google::protobuf::RepeatedPtrField< ::MapData > dataobjects_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapDataBlock* default_instance_;
};
// -------------------------------------------------------------------

class MapData : public ::google::protobuf::Message {
 public:
  MapData();
  virtual ~MapData();
  
  MapData(const MapData& from);
  
  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapData& default_instance();
  
  void Swap(MapData* other);
  
  // implements Message ----------------------------------------------
  
  MapData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes coordinates = 1;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::std::string& coordinates() const;
  inline void set_coordinates(const ::std::string& value);
  inline void set_coordinates(const char* value);
  inline void set_coordinates(const void* value, size_t size);
  inline ::std::string* mutable_coordinates();
  
  // optional bytes areaCoordinates = 2;
  inline bool has_areacoordinates() const;
  inline void clear_areacoordinates();
  static const int kAreaCoordinatesFieldNumber = 2;
  inline const ::std::string& areacoordinates() const;
  inline void set_areacoordinates(const ::std::string& value);
  inline void set_areacoordinates(const char* value);
  inline void set_areacoordinates(const void* value, size_t size);
  inline ::std::string* mutable_areacoordinates();
  
  // repeated bytes polygonInnerCoordinates = 4;
  inline int polygoninnercoordinates_size() const;
  inline void clear_polygoninnercoordinates();
  static const int kPolygonInnerCoordinatesFieldNumber = 4;
  inline const ::std::string& polygoninnercoordinates(int index) const;
  inline ::std::string* mutable_polygoninnercoordinates(int index);
  inline void set_polygoninnercoordinates(int index, const ::std::string& value);
  inline void set_polygoninnercoordinates(int index, const char* value);
  inline void set_polygoninnercoordinates(int index, const void* value, size_t size);
  inline ::std::string* add_polygoninnercoordinates();
  inline void add_polygoninnercoordinates(const ::std::string& value);
  inline void add_polygoninnercoordinates(const char* value);
  inline void add_polygoninnercoordinates(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& polygoninnercoordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_polygoninnercoordinates();
  
  // optional bytes additionalTypes = 6;
  inline bool has_additionaltypes() const;
  inline void clear_additionaltypes();
  static const int kAdditionalTypesFieldNumber = 6;
  inline const ::std::string& additionaltypes() const;
  inline void set_additionaltypes(const ::std::string& value);
  inline void set_additionaltypes(const char* value);
  inline void set_additionaltypes(const void* value, size_t size);
  inline ::std::string* mutable_additionaltypes();
  
  // required bytes types = 7;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 7;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  
  // optional bytes stringNames = 10;
  inline bool has_stringnames() const;
  inline void clear_stringnames();
  static const int kStringNamesFieldNumber = 10;
  inline const ::std::string& stringnames() const;
  inline void set_stringnames(const ::std::string& value);
  inline void set_stringnames(const char* value);
  inline void set_stringnames(const void* value, size_t size);
  inline ::std::string* mutable_stringnames();
  
  // required sint64 id = 12;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 12;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // optional bytes rasterBytes = 15;
  inline bool has_rasterbytes() const;
  inline void clear_rasterbytes();
  static const int kRasterBytesFieldNumber = 15;
  inline const ::std::string& rasterbytes() const;
  inline void set_rasterbytes(const ::std::string& value);
  inline void set_rasterbytes(const char* value);
  inline void set_rasterbytes(const void* value, size_t size);
  inline ::std::string* mutable_rasterbytes();
  
  // @@protoc_insertion_point(class_scope:MapData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* coordinates_;
  static const ::std::string _default_coordinates_;
  ::std::string* areacoordinates_;
  static const ::std::string _default_areacoordinates_;
  ::google::protobuf::RepeatedPtrField< ::std::string> polygoninnercoordinates_;
  ::std::string* additionaltypes_;
  static const ::std::string _default_additionaltypes_;
  ::std::string* types_;
  static const ::std::string _default_types_;
  ::std::string* stringnames_;
  static const ::std::string _default_stringnames_;
  ::google::protobuf::int64 id_;
  ::std::string* rasterbytes_;
  static const ::std::string _default_rasterbytes_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapData* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavAddressIndex_CitiesIndex : public ::google::protobuf::Message {
 public:
  FlcNavAddressIndex_CitiesIndex();
  virtual ~FlcNavAddressIndex_CitiesIndex();
  
  FlcNavAddressIndex_CitiesIndex(const FlcNavAddressIndex_CitiesIndex& from);
  
  inline FlcNavAddressIndex_CitiesIndex& operator=(const FlcNavAddressIndex_CitiesIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavAddressIndex_CitiesIndex& default_instance();
  
  void Swap(FlcNavAddressIndex_CitiesIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavAddressIndex_CitiesIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavAddressIndex_CitiesIndex& from);
  void MergeFrom(const FlcNavAddressIndex_CitiesIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // repeated .CityIndex cities = 5;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 5;
  inline const ::CityIndex& cities(int index) const;
  inline ::CityIndex* mutable_cities(int index);
  inline ::CityIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
      mutable_cities();
  
  // repeated .CityBlockIndex blocks = 7;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 7;
  inline const ::CityBlockIndex& blocks(int index) const;
  inline ::CityBlockIndex* mutable_blocks(int index);
  inline ::CityBlockIndex* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >*
      mutable_blocks();
  
  // @@protoc_insertion_point(class_scope:FlcNavAddressIndex.CitiesIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedPtrField< ::CityIndex > cities_;
  ::google::protobuf::RepeatedPtrField< ::CityBlockIndex > blocks_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavAddressIndex_CitiesIndex* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavAddressIndex : public ::google::protobuf::Message {
 public:
  FlcNavAddressIndex();
  virtual ~FlcNavAddressIndex();
  
  FlcNavAddressIndex(const FlcNavAddressIndex& from);
  
  inline FlcNavAddressIndex& operator=(const FlcNavAddressIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavAddressIndex& default_instance();
  
  void Swap(FlcNavAddressIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavAddressIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavAddressIndex& from);
  void MergeFrom(const FlcNavAddressIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlcNavAddressIndex_CitiesIndex CitiesIndex;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional .FlcNavTileBox boundaries = 3;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 3;
  inline const ::FlcNavTileBox& boundaries() const;
  inline ::FlcNavTileBox* mutable_boundaries();
  
  // repeated .FlcNavAddressIndex.CitiesIndex cities = 6;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 6;
  inline const ::FlcNavAddressIndex_CitiesIndex& cities(int index) const;
  inline ::FlcNavAddressIndex_CitiesIndex* mutable_cities(int index);
  inline ::FlcNavAddressIndex_CitiesIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex_CitiesIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex_CitiesIndex >*
      mutable_cities();
  
  // optional .FlcNavAddressNameIndexData nameIndex = 7;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 7;
  inline const ::FlcNavAddressNameIndexData& nameindex() const;
  inline ::FlcNavAddressNameIndexData* mutable_nameindex();
  
  // @@protoc_insertion_point(class_scope:FlcNavAddressIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::FlcNavTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex_CitiesIndex > cities_;
  ::FlcNavAddressNameIndexData* nameindex_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavAddressIndex* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavAddressNameIndexData_AddressNameIndexData : public ::google::protobuf::Message {
 public:
  FlcNavAddressNameIndexData_AddressNameIndexData();
  virtual ~FlcNavAddressNameIndexData_AddressNameIndexData();
  
  FlcNavAddressNameIndexData_AddressNameIndexData(const FlcNavAddressNameIndexData_AddressNameIndexData& from);
  
  inline FlcNavAddressNameIndexData_AddressNameIndexData& operator=(const FlcNavAddressNameIndexData_AddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavAddressNameIndexData_AddressNameIndexData& default_instance();
  
  void Swap(FlcNavAddressNameIndexData_AddressNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavAddressNameIndexData_AddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavAddressNameIndexData_AddressNameIndexData& from);
  void MergeFrom(const FlcNavAddressNameIndexData_AddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .AddressNameIndexDataAtom atom = 4;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 4;
  inline const ::AddressNameIndexDataAtom& atom(int index) const;
  inline ::AddressNameIndexDataAtom* mutable_atom(int index);
  inline ::AddressNameIndexDataAtom* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >*
      mutable_atom();
  
  // @@protoc_insertion_point(class_scope:FlcNavAddressNameIndexData.AddressNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom > atom_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavAddressNameIndexData_AddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavAddressNameIndexData : public ::google::protobuf::Message {
 public:
  FlcNavAddressNameIndexData();
  virtual ~FlcNavAddressNameIndexData();
  
  FlcNavAddressNameIndexData(const FlcNavAddressNameIndexData& from);
  
  inline FlcNavAddressNameIndexData& operator=(const FlcNavAddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavAddressNameIndexData& default_instance();
  
  void Swap(FlcNavAddressNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavAddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavAddressNameIndexData& from);
  void MergeFrom(const FlcNavAddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlcNavAddressNameIndexData_AddressNameIndexData AddressNameIndexData;
  
  // accessors -------------------------------------------------------
  
  // required .IndexedStringTable table = 4;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 4;
  inline const ::IndexedStringTable& table() const;
  inline ::IndexedStringTable* mutable_table();
  
  // repeated .FlcNavAddressNameIndexData.AddressNameIndexData atom = 7;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 7;
  inline const ::FlcNavAddressNameIndexData_AddressNameIndexData& atom(int index) const;
  inline ::FlcNavAddressNameIndexData_AddressNameIndexData* mutable_atom(int index);
  inline ::FlcNavAddressNameIndexData_AddressNameIndexData* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressNameIndexData_AddressNameIndexData >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressNameIndexData_AddressNameIndexData >*
      mutable_atom();
  
  // @@protoc_insertion_point(class_scope:FlcNavAddressNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavAddressNameIndexData_AddressNameIndexData > atom_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavAddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class AddressNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  AddressNameIndexDataAtom();
  virtual ~AddressNameIndexDataAtom();
  
  AddressNameIndexDataAtom(const AddressNameIndexDataAtom& from);
  
  inline AddressNameIndexDataAtom& operator=(const AddressNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressNameIndexDataAtom& default_instance();
  
  void Swap(AddressNameIndexDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  AddressNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressNameIndexDataAtom& from);
  void MergeFrom(const AddressNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string nameEn = 2;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  
  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // repeated int32 shiftToIndex = 5;
  inline int shifttoindex_size() const;
  inline void clear_shifttoindex();
  static const int kShiftToIndexFieldNumber = 5;
  inline ::google::protobuf::int32 shifttoindex(int index) const;
  inline void set_shifttoindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttoindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttoindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttoindex();
  
  // repeated int32 shiftToCityIndex = 6;
  inline int shifttocityindex_size() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 6;
  inline ::google::protobuf::int32 shifttocityindex(int index) const;
  inline void set_shifttocityindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttocityindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttocityindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttocityindex();
  
  // @@protoc_insertion_point(class_scope:AddressNameIndexDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* nameen_;
  static const ::std::string _default_nameen_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttoindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttocityindex_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddressNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class CityIndex : public ::google::protobuf::Message {
 public:
  CityIndex();
  virtual ~CityIndex();
  
  CityIndex(const CityIndex& from);
  
  inline CityIndex& operator=(const CityIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CityIndex& default_instance();
  
  void Swap(CityIndex* other);
  
  // implements Message ----------------------------------------------
  
  CityIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityIndex& from);
  void MergeFrom(const CityIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 city_type = 1;
  inline bool has_city_type() const;
  inline void clear_city_type();
  static const int kCityTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 city_type() const;
  inline void set_city_type(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional uint64 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // required uint32 x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // required uint32 y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional fixed32 shiftToCityBlockIndex = 10;
  inline bool has_shifttocityblockindex() const;
  inline void clear_shifttocityblockindex();
  static const int kShiftToCityBlockIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 shifttocityblockindex() const;
  inline void set_shifttocityblockindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:CityIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 city_type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shifttocityblockindex_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CityIndex* default_instance_;
};
// -------------------------------------------------------------------

class CityBlockIndex : public ::google::protobuf::Message {
 public:
  CityBlockIndex();
  virtual ~CityBlockIndex();
  
  CityBlockIndex(const CityBlockIndex& from);
  
  inline CityBlockIndex& operator=(const CityBlockIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CityBlockIndex& default_instance();
  
  void Swap(CityBlockIndex* other);
  
  // implements Message ----------------------------------------------
  
  CityBlockIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityBlockIndex& from);
  void MergeFrom(const CityBlockIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed32 shiftToCityIndex = 4;
  inline bool has_shifttocityindex() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 shifttocityindex() const;
  inline void set_shifttocityindex(::google::protobuf::uint32 value);
  
  // repeated .BuildingIndex buildings = 10;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 10;
  inline const ::BuildingIndex& buildings(int index) const;
  inline ::BuildingIndex* mutable_buildings(int index);
  inline ::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
      mutable_buildings();
  
  // repeated .StreetIndex streets = 12;
  inline int streets_size() const;
  inline void clear_streets();
  static const int kStreetsFieldNumber = 12;
  inline const ::StreetIndex& streets(int index) const;
  inline ::StreetIndex* mutable_streets(int index);
  inline ::StreetIndex* add_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
      streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
      mutable_streets();
  
  // @@protoc_insertion_point(class_scope:CityBlockIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 shifttocityindex_;
  ::google::protobuf::RepeatedPtrField< ::BuildingIndex > buildings_;
  ::google::protobuf::RepeatedPtrField< ::StreetIndex > streets_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CityBlockIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIndex : public ::google::protobuf::Message {
 public:
  StreetIndex();
  virtual ~StreetIndex();
  
  StreetIndex(const StreetIndex& from);
  
  inline StreetIndex& operator=(const StreetIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIndex& default_instance();
  
  void Swap(StreetIndex* other);
  
  // implements Message ----------------------------------------------
  
  StreetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIndex& from);
  void MergeFrom(const StreetIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // required sint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional uint64 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // repeated .BuildingIndex buildings = 12;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 12;
  inline const ::BuildingIndex& buildings(int index) const;
  inline ::BuildingIndex* mutable_buildings(int index);
  inline ::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
      mutable_buildings();
  
  // repeated .StreetIntersection intersections = 5;
  inline int intersections_size() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 5;
  inline const ::StreetIntersection& intersections(int index) const;
  inline ::StreetIntersection* mutable_intersections(int index);
  inline ::StreetIntersection* add_intersections();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
      intersections() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
      mutable_intersections();
  
  // @@protoc_insertion_point(class_scope:StreetIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::BuildingIndex > buildings_;
  ::google::protobuf::RepeatedPtrField< ::StreetIntersection > intersections_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIntersection : public ::google::protobuf::Message {
 public:
  StreetIntersection();
  virtual ~StreetIntersection();
  
  StreetIntersection(const StreetIntersection& from);
  
  inline StreetIntersection& operator=(const StreetIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIntersection& default_instance();
  
  void Swap(StreetIntersection* other);
  
  // implements Message ----------------------------------------------
  
  StreetIntersection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIntersection& from);
  void MergeFrom(const StreetIntersection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // required sint32 intersectedX = 4;
  inline bool has_intersectedx() const;
  inline void clear_intersectedx();
  static const int kIntersectedXFieldNumber = 4;
  inline ::google::protobuf::int32 intersectedx() const;
  inline void set_intersectedx(::google::protobuf::int32 value);
  
  // required sint32 intersectedY = 5;
  inline bool has_intersectedy() const;
  inline void clear_intersectedy();
  static const int kIntersectedYFieldNumber = 5;
  inline ::google::protobuf::int32 intersectedy() const;
  inline void set_intersectedy(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:StreetIntersection)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::int32 intersectedx_;
  ::google::protobuf::int32 intersectedy_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIntersection* default_instance_;
};
// -------------------------------------------------------------------

class BuildingIndex : public ::google::protobuf::Message {
 public:
  BuildingIndex();
  virtual ~BuildingIndex();
  
  BuildingIndex(const BuildingIndex& from);
  
  inline BuildingIndex& operator=(const BuildingIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingIndex& default_instance();
  
  void Swap(BuildingIndex* other);
  
  // implements Message ----------------------------------------------
  
  BuildingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingIndex& from);
  void MergeFrom(const BuildingIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional string name2 = 3;
  inline bool has_name2() const;
  inline void clear_name2();
  static const int kName2FieldNumber = 3;
  inline const ::std::string& name2() const;
  inline void set_name2(const ::std::string& value);
  inline void set_name2(const char* value);
  inline void set_name2(const char* value, size_t size);
  inline ::std::string* mutable_name2();
  
  // optional string name_en2 = 4;
  inline bool has_name_en2() const;
  inline void clear_name_en2();
  static const int kNameEn2FieldNumber = 4;
  inline const ::std::string& name_en2() const;
  inline void set_name_en2(const ::std::string& value);
  inline void set_name_en2(const char* value);
  inline void set_name_en2(const char* value, size_t size);
  inline ::std::string* mutable_name_en2();
  
  // optional sint32 interpolation = 5;
  inline bool has_interpolation() const;
  inline void clear_interpolation();
  static const int kInterpolationFieldNumber = 5;
  inline ::google::protobuf::int32 interpolation() const;
  inline void set_interpolation(::google::protobuf::int32 value);
  
  // required sint32 x = 7;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 7;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 8;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 8;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional sint32 x2 = 9;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 9;
  inline ::google::protobuf::int32 x2() const;
  inline void set_x2(::google::protobuf::int32 value);
  
  // optional sint32 y2 = 10;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 10;
  inline ::google::protobuf::int32 y2() const;
  inline void set_y2(::google::protobuf::int32 value);
  
  // optional uint64 id = 13;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 13;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string postcode = 14;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostcodeFieldNumber = 14;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  
  // @@protoc_insertion_point(class_scope:BuildingIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::std::string* name2_;
  static const ::std::string _default_name2_;
  ::std::string* name_en2_;
  static const ::std::string _default_name_en2_;
  ::google::protobuf::int32 interpolation_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::int32 y2_;
  ::google::protobuf::uint64 id_;
  ::std::string* postcode_;
  static const ::std::string _default_postcode_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BuildingIndex* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoutes : public ::google::protobuf::Message {
 public:
  TransportRoutes();
  virtual ~TransportRoutes();
  
  TransportRoutes(const TransportRoutes& from);
  
  inline TransportRoutes& operator=(const TransportRoutes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoutes& default_instance();
  
  void Swap(TransportRoutes* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoutes& from);
  void MergeFrom(const TransportRoutes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .TransportRoute routes = 6;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 6;
  inline const ::TransportRoute& routes(int index) const;
  inline ::TransportRoute* mutable_routes(int index);
  inline ::TransportRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportRoutes)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::TransportRoute > routes_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoutes* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoute : public ::google::protobuf::Message {
 public:
  TransportRoute();
  virtual ~TransportRoute();
  
  TransportRoute(const TransportRoute& from);
  
  inline TransportRoute& operator=(const TransportRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoute& default_instance();
  
  void Swap(TransportRoute* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoute& from);
  void MergeFrom(const TransportRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::google::protobuf::uint32 operator_() const;
  inline void set_operator_(::google::protobuf::uint32 value);
  
  // optional string ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  
  // optional uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // optional uint32 distance = 8;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 8;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);
  
  // repeated .TransportRouteStop directStops = 15;
  inline int directstops_size() const;
  inline void clear_directstops();
  static const int kDirectStopsFieldNumber = 15;
  inline const ::TransportRouteStop& directstops(int index) const;
  inline ::TransportRouteStop* mutable_directstops(int index);
  inline ::TransportRouteStop* add_directstops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      directstops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_directstops();
  
  // repeated .TransportRouteStop reverseStops = 16;
  inline int reversestops_size() const;
  inline void clear_reversestops();
  static const int kReverseStopsFieldNumber = 16;
  inline const ::TransportRouteStop& reversestops(int index) const;
  inline ::TransportRouteStop* mutable_reversestops(int index);
  inline ::TransportRouteStop* add_reversestops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      reversestops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_reversestops();
  
  // @@protoc_insertion_point(class_scope:TransportRoute)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 operator__;
  ::std::string* ref_;
  static const ::std::string _default_ref_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > directstops_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > reversestops_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoute* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteStop : public ::google::protobuf::Message {
 public:
  TransportRouteStop();
  virtual ~TransportRouteStop();
  
  TransportRouteStop(const TransportRouteStop& from);
  
  inline TransportRouteStop& operator=(const TransportRouteStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteStop& default_instance();
  
  void Swap(TransportRouteStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportRouteStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteStop& from);
  void MergeFrom(const TransportRouteStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TransportRouteStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRouteStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStop : public ::google::protobuf::Message {
 public:
  TransportStop();
  virtual ~TransportStop();
  
  TransportStop(const TransportStop& from);
  
  inline TransportStop& operator=(const TransportStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStop& default_instance();
  
  void Swap(TransportStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStop& from);
  void MergeFrom(const TransportStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 2;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 2;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required sint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // repeated uint32 routes = 16;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 16;
  inline ::google::protobuf::uint32 routes(int index) const;
  inline void set_routes(int index, ::google::protobuf::uint32 value);
  inline void add_routes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      routes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > routes_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStopsTree : public ::google::protobuf::Message {
 public:
  TransportStopsTree();
  virtual ~TransportStopsTree();
  
  TransportStopsTree(const TransportStopsTree& from);
  
  inline TransportStopsTree& operator=(const TransportStopsTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStopsTree& default_instance();
  
  void Swap(TransportStopsTree* other);
  
  // implements Message ----------------------------------------------
  
  TransportStopsTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStopsTree& from);
  void MergeFrom(const TransportStopsTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .TransportStopsTree subtrees = 7;
  inline int subtrees_size() const;
  inline void clear_subtrees();
  static const int kSubtreesFieldNumber = 7;
  inline const ::TransportStopsTree& subtrees(int index) const;
  inline ::TransportStopsTree* mutable_subtrees(int index);
  inline ::TransportStopsTree* add_subtrees();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
      subtrees() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
      mutable_subtrees();
  
  // repeated .TransportStop leafs = 8;
  inline int leafs_size() const;
  inline void clear_leafs();
  static const int kLeafsFieldNumber = 8;
  inline const ::TransportStop& leafs(int index) const;
  inline ::TransportStop* mutable_leafs(int index);
  inline ::TransportStop* add_leafs();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
      leafs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
      mutable_leafs();
  
  // optional uint64 baseId = 16;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 16;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:TransportStopsTree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::TransportStopsTree > subtrees_;
  ::google::protobuf::RepeatedPtrField< ::TransportStop > leafs_;
  ::google::protobuf::uint64 baseid_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStopsTree* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavTransportIndex : public ::google::protobuf::Message {
 public:
  FlcNavTransportIndex();
  virtual ~FlcNavTransportIndex();
  
  FlcNavTransportIndex(const FlcNavTransportIndex& from);
  
  inline FlcNavTransportIndex& operator=(const FlcNavTransportIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavTransportIndex& default_instance();
  
  void Swap(FlcNavTransportIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavTransportIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavTransportIndex& from);
  void MergeFrom(const FlcNavTransportIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .TransportRoutes routes = 3;
  inline bool has_routes() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 3;
  inline const ::TransportRoutes& routes() const;
  inline ::TransportRoutes* mutable_routes();
  
  // optional .TransportStopsTree stops = 6;
  inline bool has_stops() const;
  inline void clear_stops();
  static const int kStopsFieldNumber = 6;
  inline const ::TransportStopsTree& stops() const;
  inline ::TransportStopsTree* mutable_stops();
  
  // required .StringTable stringTable = 9;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 9;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:FlcNavTransportIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::TransportRoutes* routes_;
  ::TransportStopsTree* stops_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavTransportIndex* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiIndex : public ::google::protobuf::Message {
 public:
  FlcNavPoiIndex();
  virtual ~FlcNavPoiIndex();
  
  FlcNavPoiIndex(const FlcNavPoiIndex& from);
  
  inline FlcNavPoiIndex& operator=(const FlcNavPoiIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiIndex& default_instance();
  
  void Swap(FlcNavPoiIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiIndex& from);
  void MergeFrom(const FlcNavPoiIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .FlcNavTileBox boundaries = 2;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 2;
  inline const ::FlcNavTileBox& boundaries() const;
  inline ::FlcNavTileBox* mutable_boundaries();
  
  // repeated .FlcNavCategoryTable categoriesTable = 3;
  inline int categoriestable_size() const;
  inline void clear_categoriestable();
  static const int kCategoriesTableFieldNumber = 3;
  inline const ::FlcNavCategoryTable& categoriestable(int index) const;
  inline ::FlcNavCategoryTable* mutable_categoriestable(int index);
  inline ::FlcNavCategoryTable* add_categoriestable();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavCategoryTable >&
      categoriestable() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavCategoryTable >*
      mutable_categoriestable();
  
  // optional .FlcNavPoiNameIndex nameIndex = 4;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 4;
  inline const ::FlcNavPoiNameIndex& nameindex() const;
  inline ::FlcNavPoiNameIndex* mutable_nameindex();
  
  // repeated .FlcNavPoiBox boxes = 6;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 6;
  inline const ::FlcNavPoiBox& boxes(int index) const;
  inline ::FlcNavPoiBox* mutable_boxes(int index);
  inline ::FlcNavPoiBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >*
      mutable_boxes();
  
  // repeated .FlcNavPoiBoxData poiData = 9;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 9;
  inline const ::FlcNavPoiBoxData& poidata(int index) const;
  inline ::FlcNavPoiBoxData* mutable_poidata(int index);
  inline ::FlcNavPoiBoxData* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxData >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxData >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::FlcNavTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavCategoryTable > categoriestable_;
  ::FlcNavPoiNameIndex* nameindex_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxData > poidata_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiIndex* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiNameIndex_FlcNavPoiNameIndexData : public ::google::protobuf::Message {
 public:
  FlcNavPoiNameIndex_FlcNavPoiNameIndexData();
  virtual ~FlcNavPoiNameIndex_FlcNavPoiNameIndexData();
  
  FlcNavPoiNameIndex_FlcNavPoiNameIndexData(const FlcNavPoiNameIndex_FlcNavPoiNameIndexData& from);
  
  inline FlcNavPoiNameIndex_FlcNavPoiNameIndexData& operator=(const FlcNavPoiNameIndex_FlcNavPoiNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiNameIndex_FlcNavPoiNameIndexData& default_instance();
  
  void Swap(FlcNavPoiNameIndex_FlcNavPoiNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiNameIndex_FlcNavPoiNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiNameIndex_FlcNavPoiNameIndexData& from);
  void MergeFrom(const FlcNavPoiNameIndex_FlcNavPoiNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FlcNavPoiNameIndexDataAtom atoms = 3;
  inline int atoms_size() const;
  inline void clear_atoms();
  static const int kAtomsFieldNumber = 3;
  inline const ::FlcNavPoiNameIndexDataAtom& atoms(int index) const;
  inline ::FlcNavPoiNameIndexDataAtom* mutable_atoms(int index);
  inline ::FlcNavPoiNameIndexDataAtom* add_atoms();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndexDataAtom >&
      atoms() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndexDataAtom >*
      mutable_atoms();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiNameIndex.FlcNavPoiNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndexDataAtom > atoms_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiNameIndex_FlcNavPoiNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiNameIndex : public ::google::protobuf::Message {
 public:
  FlcNavPoiNameIndex();
  virtual ~FlcNavPoiNameIndex();
  
  FlcNavPoiNameIndex(const FlcNavPoiNameIndex& from);
  
  inline FlcNavPoiNameIndex& operator=(const FlcNavPoiNameIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiNameIndex& default_instance();
  
  void Swap(FlcNavPoiNameIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiNameIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiNameIndex& from);
  void MergeFrom(const FlcNavPoiNameIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlcNavPoiNameIndex_FlcNavPoiNameIndexData FlcNavPoiNameIndexData;
  
  // accessors -------------------------------------------------------
  
  // required .IndexedStringTable table = 3;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 3;
  inline const ::IndexedStringTable& table() const;
  inline ::IndexedStringTable* mutable_table();
  
  // repeated .FlcNavPoiNameIndex.FlcNavPoiNameIndexData data = 5;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData& data(int index) const;
  inline ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData* mutable_data(int index);
  inline ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiNameIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData > data_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiNameIndex* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  FlcNavPoiNameIndexDataAtom();
  virtual ~FlcNavPoiNameIndexDataAtom();
  
  FlcNavPoiNameIndexDataAtom(const FlcNavPoiNameIndexDataAtom& from);
  
  inline FlcNavPoiNameIndexDataAtom& operator=(const FlcNavPoiNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiNameIndexDataAtom& default_instance();
  
  void Swap(FlcNavPoiNameIndexDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiNameIndexDataAtom& from);
  void MergeFrom(const FlcNavPoiNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 2;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 2;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional fixed32 shiftTo = 14;
  inline bool has_shiftto() const;
  inline void clear_shiftto();
  static const int kShiftToFieldNumber = 14;
  inline ::google::protobuf::uint32 shiftto() const;
  inline void set_shiftto(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiNameIndexDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shiftto_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavCategoryTable : public ::google::protobuf::Message {
 public:
  FlcNavCategoryTable();
  virtual ~FlcNavCategoryTable();
  
  FlcNavCategoryTable(const FlcNavCategoryTable& from);
  
  inline FlcNavCategoryTable& operator=(const FlcNavCategoryTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavCategoryTable& default_instance();
  
  void Swap(FlcNavCategoryTable* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavCategoryTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavCategoryTable& from);
  void MergeFrom(const FlcNavCategoryTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  
  // repeated string subcategories = 3;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 3;
  inline const ::std::string& subcategories(int index) const;
  inline ::std::string* mutable_subcategories(int index);
  inline void set_subcategories(int index, const ::std::string& value);
  inline void set_subcategories(int index, const char* value);
  inline void set_subcategories(int index, const char* value, size_t size);
  inline ::std::string* add_subcategories();
  inline void add_subcategories(const ::std::string& value);
  inline void add_subcategories(const char* value);
  inline void add_subcategories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subcategories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subcategories();
  
  // @@protoc_insertion_point(class_scope:FlcNavCategoryTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* category_;
  static const ::std::string _default_category_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subcategories_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavCategoryTable* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiBox : public ::google::protobuf::Message {
 public:
  FlcNavPoiBox();
  virtual ~FlcNavPoiBox();
  
  FlcNavPoiBox(const FlcNavPoiBox& from);
  
  inline FlcNavPoiBox& operator=(const FlcNavPoiBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiBox& default_instance();
  
  void Swap(FlcNavPoiBox* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiBox& from);
  void MergeFrom(const FlcNavPoiBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // required sint32 left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // optional .FlcNavPoiCategories categories = 4;
  inline bool has_categories() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline const ::FlcNavPoiCategories& categories() const;
  inline ::FlcNavPoiCategories* mutable_categories();
  
  // repeated .FlcNavPoiBox subBoxes = 10;
  inline int subboxes_size() const;
  inline void clear_subboxes();
  static const int kSubBoxesFieldNumber = 10;
  inline const ::FlcNavPoiBox& subboxes(int index) const;
  inline ::FlcNavPoiBox* mutable_subboxes(int index);
  inline ::FlcNavPoiBox* add_subboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >&
      subboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >*
      mutable_subboxes();
  
  // optional fixed32 shiftToData = 14;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 14;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::FlcNavPoiCategories* categories_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox > subboxes_;
  ::google::protobuf::uint32 shifttodata_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiBox* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiCategories : public ::google::protobuf::Message {
 public:
  FlcNavPoiCategories();
  virtual ~FlcNavPoiCategories();
  
  FlcNavPoiCategories(const FlcNavPoiCategories& from);
  
  inline FlcNavPoiCategories& operator=(const FlcNavPoiCategories& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiCategories& default_instance();
  
  void Swap(FlcNavPoiCategories* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiCategories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiCategories& from);
  void MergeFrom(const FlcNavPoiCategories& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 categories = 3;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 3;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiCategories)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiCategories* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiBoxData : public ::google::protobuf::Message {
 public:
  FlcNavPoiBoxData();
  virtual ~FlcNavPoiBoxData();
  
  FlcNavPoiBoxData(const FlcNavPoiBoxData& from);
  
  inline FlcNavPoiBoxData& operator=(const FlcNavPoiBoxData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiBoxData& default_instance();
  
  void Swap(FlcNavPoiBoxData* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiBoxData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiBoxData& from);
  void MergeFrom(const FlcNavPoiBoxData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // repeated .FlcNavPoiBoxDataAtom poiData = 5;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 5;
  inline const ::FlcNavPoiBoxDataAtom& poidata(int index) const;
  inline ::FlcNavPoiBoxDataAtom* mutable_poidata(int index);
  inline ::FlcNavPoiBoxDataAtom* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxDataAtom >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxDataAtom >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiBoxData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxDataAtom > poidata_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiBoxData* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavPoiBoxDataAtom : public ::google::protobuf::Message {
 public:
  FlcNavPoiBoxDataAtom();
  virtual ~FlcNavPoiBoxDataAtom();
  
  FlcNavPoiBoxDataAtom(const FlcNavPoiBoxDataAtom& from);
  
  inline FlcNavPoiBoxDataAtom& operator=(const FlcNavPoiBoxDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavPoiBoxDataAtom& default_instance();
  
  void Swap(FlcNavPoiBoxDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavPoiBoxDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavPoiBoxDataAtom& from);
  void MergeFrom(const FlcNavPoiBoxDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // repeated uint32 categories = 4;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string nameEn = 7;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 7;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  
  // optional uint64 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string openingHours = 10;
  inline bool has_openinghours() const;
  inline void clear_openinghours();
  static const int kOpeningHoursFieldNumber = 10;
  inline const ::std::string& openinghours() const;
  inline void set_openinghours(const ::std::string& value);
  inline void set_openinghours(const char* value);
  inline void set_openinghours(const char* value, size_t size);
  inline ::std::string* mutable_openinghours();
  
  // optional string site = 11;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 11;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  
  // optional string phone = 12;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 12;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  
  // optional string note = 13;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 13;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  
  // @@protoc_insertion_point(class_scope:FlcNavPoiBoxDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* nameen_;
  static const ::std::string _default_nameen_;
  ::google::protobuf::uint64 id_;
  ::std::string* openinghours_;
  static const ::std::string _default_openinghours_;
  ::std::string* site_;
  static const ::std::string _default_site_;
  ::std::string* phone_;
  static const ::std::string _default_phone_;
  ::std::string* note_;
  static const ::std::string _default_note_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavPoiBoxDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class IdTable : public ::google::protobuf::Message {
 public:
  IdTable();
  virtual ~IdTable();
  
  IdTable(const IdTable& from);
  
  inline IdTable& operator=(const IdTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IdTable& default_instance();
  
  void Swap(IdTable* other);
  
  // implements Message ----------------------------------------------
  
  IdTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IdTable& from);
  void MergeFrom(const IdTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated sint64 routeId = 1;
  inline int routeid_size() const;
  inline void clear_routeid();
  static const int kRouteIdFieldNumber = 1;
  inline ::google::protobuf::int64 routeid(int index) const;
  inline void set_routeid(int index, ::google::protobuf::int64 value);
  inline void add_routeid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      routeid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_routeid();
  
  // @@protoc_insertion_point(class_scope:IdTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > routeid_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IdTable* default_instance_;
};
// -------------------------------------------------------------------

class RestrictionData : public ::google::protobuf::Message {
 public:
  RestrictionData();
  virtual ~RestrictionData();
  
  RestrictionData(const RestrictionData& from);
  
  inline RestrictionData& operator=(const RestrictionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RestrictionData& default_instance();
  
  void Swap(RestrictionData* other);
  
  // implements Message ----------------------------------------------
  
  RestrictionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RestrictionData& from);
  void MergeFrom(const RestrictionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);
  
  // required int32 to = 3;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 3;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);
  
  // optional int32 via = 4;
  inline bool has_via() const;
  inline void clear_via();
  static const int kViaFieldNumber = 4;
  inline ::google::protobuf::int32 via() const;
  inline void set_via(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:RestrictionData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  ::google::protobuf::int32 via_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RestrictionData* default_instance_;
};
// -------------------------------------------------------------------

class RouteData : public ::google::protobuf::Message {
 public:
  RouteData();
  virtual ~RouteData();
  
  RouteData(const RouteData& from);
  
  inline RouteData& operator=(const RouteData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteData& default_instance();
  
  void Swap(RouteData* other);
  
  // implements Message ----------------------------------------------
  
  RouteData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteData& from);
  void MergeFrom(const RouteData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes points = 1;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::std::string& points() const;
  inline void set_points(const ::std::string& value);
  inline void set_points(const char* value);
  inline void set_points(const void* value, size_t size);
  inline ::std::string* mutable_points();
  
  // optional bytes pointTypes = 4;
  inline bool has_pointtypes() const;
  inline void clear_pointtypes();
  static const int kPointTypesFieldNumber = 4;
  inline const ::std::string& pointtypes() const;
  inline void set_pointtypes(const ::std::string& value);
  inline void set_pointtypes(const char* value);
  inline void set_pointtypes(const void* value, size_t size);
  inline ::std::string* mutable_pointtypes();
  
  // optional bytes pointJNInd = 5;
  inline bool has_pointjnind() const;
  inline void clear_pointjnind();
  static const int kPointJNIndFieldNumber = 5;
  inline const ::std::string& pointjnind() const;
  inline void set_pointjnind(const ::std::string& value);
  inline void set_pointjnind(const char* value);
  inline void set_pointjnind(const void* value, size_t size);
  inline ::std::string* mutable_pointjnind();
  
  // optional bytes pointJNWayIds = 6;
  inline bool has_pointjnwayids() const;
  inline void clear_pointjnwayids();
  static const int kPointJNWayIdsFieldNumber = 6;
  inline const ::std::string& pointjnwayids() const;
  inline void set_pointjnwayids(const ::std::string& value);
  inline void set_pointjnwayids(const char* value);
  inline void set_pointjnwayids(const void* value, size_t size);
  inline ::std::string* mutable_pointjnwayids();
  
  // required bytes types = 7;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 7;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  
  // required int32 routeId = 12;
  inline bool has_routeid() const;
  inline void clear_routeid();
  static const int kRouteIdFieldNumber = 12;
  inline ::google::protobuf::int32 routeid() const;
  inline void set_routeid(::google::protobuf::int32 value);
  
  // optional bytes stringNames = 14;
  inline bool has_stringnames() const;
  inline void clear_stringnames();
  static const int kStringNamesFieldNumber = 14;
  inline const ::std::string& stringnames() const;
  inline void set_stringnames(const ::std::string& value);
  inline void set_stringnames(const char* value);
  inline void set_stringnames(const void* value, size_t size);
  inline ::std::string* mutable_stringnames();
  
  // @@protoc_insertion_point(class_scope:RouteData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* points_;
  static const ::std::string _default_points_;
  ::std::string* pointtypes_;
  static const ::std::string _default_pointtypes_;
  ::std::string* pointjnind_;
  static const ::std::string _default_pointjnind_;
  ::std::string* pointjnwayids_;
  static const ::std::string _default_pointjnwayids_;
  ::std::string* types_;
  static const ::std::string _default_types_;
  ::google::protobuf::int32 routeid_;
  ::std::string* stringnames_;
  static const ::std::string _default_stringnames_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RouteData* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavRoutingIndex_RouteEncodingRule : public ::google::protobuf::Message {
 public:
  FlcNavRoutingIndex_RouteEncodingRule();
  virtual ~FlcNavRoutingIndex_RouteEncodingRule();
  
  FlcNavRoutingIndex_RouteEncodingRule(const FlcNavRoutingIndex_RouteEncodingRule& from);
  
  inline FlcNavRoutingIndex_RouteEncodingRule& operator=(const FlcNavRoutingIndex_RouteEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavRoutingIndex_RouteEncodingRule& default_instance();
  
  void Swap(FlcNavRoutingIndex_RouteEncodingRule* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavRoutingIndex_RouteEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavRoutingIndex_RouteEncodingRule& from);
  void MergeFrom(const FlcNavRoutingIndex_RouteEncodingRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // required string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional uint32 id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FlcNavRoutingIndex.RouteEncodingRule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavRoutingIndex_RouteEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavRoutingIndex_RouteDataBox : public ::google::protobuf::Message {
 public:
  FlcNavRoutingIndex_RouteDataBox();
  virtual ~FlcNavRoutingIndex_RouteDataBox();
  
  FlcNavRoutingIndex_RouteDataBox(const FlcNavRoutingIndex_RouteDataBox& from);
  
  inline FlcNavRoutingIndex_RouteDataBox& operator=(const FlcNavRoutingIndex_RouteDataBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavRoutingIndex_RouteDataBox& default_instance();
  
  void Swap(FlcNavRoutingIndex_RouteDataBox* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavRoutingIndex_RouteDataBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavRoutingIndex_RouteDataBox& from);
  void MergeFrom(const FlcNavRoutingIndex_RouteDataBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // optional fixed32 shiftToData = 5;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 5;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);
  
  // repeated .FlcNavRoutingIndex.RouteDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::FlcNavRoutingIndex_RouteDataBox& boxes(int index) const;
  inline ::FlcNavRoutingIndex_RouteDataBox* mutable_boxes(int index);
  inline ::FlcNavRoutingIndex_RouteDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >*
      mutable_boxes();
  
  // @@protoc_insertion_point(class_scope:FlcNavRoutingIndex.RouteDataBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::uint32 shifttodata_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox > boxes_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavRoutingIndex_RouteDataBox* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavRoutingIndex_RouteDataBlock : public ::google::protobuf::Message {
 public:
  FlcNavRoutingIndex_RouteDataBlock();
  virtual ~FlcNavRoutingIndex_RouteDataBlock();
  
  FlcNavRoutingIndex_RouteDataBlock(const FlcNavRoutingIndex_RouteDataBlock& from);
  
  inline FlcNavRoutingIndex_RouteDataBlock& operator=(const FlcNavRoutingIndex_RouteDataBlock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavRoutingIndex_RouteDataBlock& default_instance();
  
  void Swap(FlcNavRoutingIndex_RouteDataBlock* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavRoutingIndex_RouteDataBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavRoutingIndex_RouteDataBlock& from);
  void MergeFrom(const FlcNavRoutingIndex_RouteDataBlock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .IdTable idTable = 5;
  inline bool has_idtable() const;
  inline void clear_idtable();
  static const int kIdTableFieldNumber = 5;
  inline const ::IdTable& idtable() const;
  inline ::IdTable* mutable_idtable();
  
  // optional .StringTable stringTable = 8;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 8;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // repeated .RouteData dataObjects = 6;
  inline int dataobjects_size() const;
  inline void clear_dataobjects();
  static const int kDataObjectsFieldNumber = 6;
  inline const ::RouteData& dataobjects(int index) const;
  inline ::RouteData* mutable_dataobjects(int index);
  inline ::RouteData* add_dataobjects();
  inline const ::google::protobuf::RepeatedPtrField< ::RouteData >&
      dataobjects() const;
  inline ::google::protobuf::RepeatedPtrField< ::RouteData >*
      mutable_dataobjects();
  
  // repeated .RestrictionData restrictions = 7;
  inline int restrictions_size() const;
  inline void clear_restrictions();
  static const int kRestrictionsFieldNumber = 7;
  inline const ::RestrictionData& restrictions(int index) const;
  inline ::RestrictionData* mutable_restrictions(int index);
  inline ::RestrictionData* add_restrictions();
  inline const ::google::protobuf::RepeatedPtrField< ::RestrictionData >&
      restrictions() const;
  inline ::google::protobuf::RepeatedPtrField< ::RestrictionData >*
      mutable_restrictions();
  
  // @@protoc_insertion_point(class_scope:FlcNavRoutingIndex.RouteDataBlock)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IdTable* idtable_;
  ::StringTable* stringtable_;
  ::google::protobuf::RepeatedPtrField< ::RouteData > dataobjects_;
  ::google::protobuf::RepeatedPtrField< ::RestrictionData > restrictions_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavRoutingIndex_RouteDataBlock* default_instance_;
};
// -------------------------------------------------------------------

class FlcNavRoutingIndex : public ::google::protobuf::Message {
 public:
  FlcNavRoutingIndex();
  virtual ~FlcNavRoutingIndex();
  
  FlcNavRoutingIndex(const FlcNavRoutingIndex& from);
  
  inline FlcNavRoutingIndex& operator=(const FlcNavRoutingIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlcNavRoutingIndex& default_instance();
  
  void Swap(FlcNavRoutingIndex* other);
  
  // implements Message ----------------------------------------------
  
  FlcNavRoutingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlcNavRoutingIndex& from);
  void MergeFrom(const FlcNavRoutingIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlcNavRoutingIndex_RouteEncodingRule RouteEncodingRule;
  typedef FlcNavRoutingIndex_RouteDataBox RouteDataBox;
  typedef FlcNavRoutingIndex_RouteDataBlock RouteDataBlock;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .FlcNavRoutingIndex.RouteEncodingRule rules = 2;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 2;
  inline const ::FlcNavRoutingIndex_RouteEncodingRule& rules(int index) const;
  inline ::FlcNavRoutingIndex_RouteEncodingRule* mutable_rules(int index);
  inline ::FlcNavRoutingIndex_RouteEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteEncodingRule >*
      mutable_rules();
  
  // repeated .FlcNavRoutingIndex.RouteDataBox rootBoxes = 3;
  inline int rootboxes_size() const;
  inline void clear_rootboxes();
  static const int kRootBoxesFieldNumber = 3;
  inline const ::FlcNavRoutingIndex_RouteDataBox& rootboxes(int index) const;
  inline ::FlcNavRoutingIndex_RouteDataBox* mutable_rootboxes(int index);
  inline ::FlcNavRoutingIndex_RouteDataBox* add_rootboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >&
      rootboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >*
      mutable_rootboxes();
  
  // repeated .FlcNavRoutingIndex.RouteDataBlock blocks = 5;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 5;
  inline const ::FlcNavRoutingIndex_RouteDataBlock& blocks(int index) const;
  inline ::FlcNavRoutingIndex_RouteDataBlock* mutable_blocks(int index);
  inline ::FlcNavRoutingIndex_RouteDataBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBlock >*
      mutable_blocks();
  
  // @@protoc_insertion_point(class_scope:FlcNavRoutingIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteEncodingRule > rules_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox > rootboxes_;
  ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBlock > blocks_;
  friend void  protobuf_AddDesc_flcnav_5fodb_2eproto();
  friend void protobuf_AssignDesc_flcnav_5fodb_2eproto();
  friend void protobuf_ShutdownFile_flcnav_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FlcNavRoutingIndex* default_instance_;
};
// ===================================================================


// ===================================================================

// FlcNavStructure

// required uint32 version = 1;
inline bool FlcNavStructure::has_version() const {
  return _has_bit(0);
}
inline void FlcNavStructure::clear_version() {
  version_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavStructure::version() const {
  return version_;
}
inline void FlcNavStructure::set_version(::google::protobuf::uint32 value) {
  _set_bit(0);
  version_ = value;
}

// required int64 dateCreated = 18;
inline bool FlcNavStructure::has_datecreated() const {
  return _has_bit(1);
}
inline void FlcNavStructure::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 FlcNavStructure::datecreated() const {
  return datecreated_;
}
inline void FlcNavStructure::set_datecreated(::google::protobuf::int64 value) {
  _set_bit(1);
  datecreated_ = value;
}

// repeated .FlcNavAddressIndex addressIndex = 7;
inline int FlcNavStructure::addressindex_size() const {
  return addressindex_.size();
}
inline void FlcNavStructure::clear_addressindex() {
  addressindex_.Clear();
}
inline const ::FlcNavAddressIndex& FlcNavStructure::addressindex(int index) const {
  return addressindex_.Get(index);
}
inline ::FlcNavAddressIndex* FlcNavStructure::mutable_addressindex(int index) {
  return addressindex_.Mutable(index);
}
inline ::FlcNavAddressIndex* FlcNavStructure::add_addressindex() {
  return addressindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex >&
FlcNavStructure::addressindex() const {
  return addressindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex >*
FlcNavStructure::mutable_addressindex() {
  return &addressindex_;
}

// repeated .FlcNavTransportIndex transportIndex = 4;
inline int FlcNavStructure::transportindex_size() const {
  return transportindex_.size();
}
inline void FlcNavStructure::clear_transportindex() {
  transportindex_.Clear();
}
inline const ::FlcNavTransportIndex& FlcNavStructure::transportindex(int index) const {
  return transportindex_.Get(index);
}
inline ::FlcNavTransportIndex* FlcNavStructure::mutable_transportindex(int index) {
  return transportindex_.Mutable(index);
}
inline ::FlcNavTransportIndex* FlcNavStructure::add_transportindex() {
  return transportindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavTransportIndex >&
FlcNavStructure::transportindex() const {
  return transportindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavTransportIndex >*
FlcNavStructure::mutable_transportindex() {
  return &transportindex_;
}

// repeated .FlcNavPoiIndex poiIndex = 8;
inline int FlcNavStructure::poiindex_size() const {
  return poiindex_.size();
}
inline void FlcNavStructure::clear_poiindex() {
  poiindex_.Clear();
}
inline const ::FlcNavPoiIndex& FlcNavStructure::poiindex(int index) const {
  return poiindex_.Get(index);
}
inline ::FlcNavPoiIndex* FlcNavStructure::mutable_poiindex(int index) {
  return poiindex_.Mutable(index);
}
inline ::FlcNavPoiIndex* FlcNavStructure::add_poiindex() {
  return poiindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiIndex >&
FlcNavStructure::poiindex() const {
  return poiindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiIndex >*
FlcNavStructure::mutable_poiindex() {
  return &poiindex_;
}

// repeated .FlcNavMapIndex mapIndex = 6;
inline int FlcNavStructure::mapindex_size() const {
  return mapindex_.size();
}
inline void FlcNavStructure::clear_mapindex() {
  mapindex_.Clear();
}
inline const ::FlcNavMapIndex& FlcNavStructure::mapindex(int index) const {
  return mapindex_.Get(index);
}
inline ::FlcNavMapIndex* FlcNavStructure::mutable_mapindex(int index) {
  return mapindex_.Mutable(index);
}
inline ::FlcNavMapIndex* FlcNavStructure::add_mapindex() {
  return mapindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex >&
FlcNavStructure::mapindex() const {
  return mapindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex >*
FlcNavStructure::mutable_mapindex() {
  return &mapindex_;
}

// repeated .FlcNavRoutingIndex routingIndex = 9;
inline int FlcNavStructure::routingindex_size() const {
  return routingindex_.size();
}
inline void FlcNavStructure::clear_routingindex() {
  routingindex_.Clear();
}
inline const ::FlcNavRoutingIndex& FlcNavStructure::routingindex(int index) const {
  return routingindex_.Get(index);
}
inline ::FlcNavRoutingIndex* FlcNavStructure::mutable_routingindex(int index) {
  return routingindex_.Mutable(index);
}
inline ::FlcNavRoutingIndex* FlcNavStructure::add_routingindex() {
  return routingindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex >&
FlcNavStructure::routingindex() const {
  return routingindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex >*
FlcNavStructure::mutable_routingindex() {
  return &routingindex_;
}

// required uint32 versionConfirm = 32;
inline bool FlcNavStructure::has_versionconfirm() const {
  return _has_bit(7);
}
inline void FlcNavStructure::clear_versionconfirm() {
  versionconfirm_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 FlcNavStructure::versionconfirm() const {
  return versionconfirm_;
}
inline void FlcNavStructure::set_versionconfirm(::google::protobuf::uint32 value) {
  _set_bit(7);
  versionconfirm_ = value;
}

// -------------------------------------------------------------------

// FlcNavTileBox

// required uint32 left = 1;
inline bool FlcNavTileBox::has_left() const {
  return _has_bit(0);
}
inline void FlcNavTileBox::clear_left() {
  left_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavTileBox::left() const {
  return left_;
}
inline void FlcNavTileBox::set_left(::google::protobuf::uint32 value) {
  _set_bit(0);
  left_ = value;
}

// required uint32 right = 2;
inline bool FlcNavTileBox::has_right() const {
  return _has_bit(1);
}
inline void FlcNavTileBox::clear_right() {
  right_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 FlcNavTileBox::right() const {
  return right_;
}
inline void FlcNavTileBox::set_right(::google::protobuf::uint32 value) {
  _set_bit(1);
  right_ = value;
}

// required uint32 top = 3;
inline bool FlcNavTileBox::has_top() const {
  return _has_bit(2);
}
inline void FlcNavTileBox::clear_top() {
  top_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 FlcNavTileBox::top() const {
  return top_;
}
inline void FlcNavTileBox::set_top(::google::protobuf::uint32 value) {
  _set_bit(2);
  top_ = value;
}

// required uint32 bottom = 4;
inline bool FlcNavTileBox::has_bottom() const {
  return _has_bit(3);
}
inline void FlcNavTileBox::clear_bottom() {
  bottom_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 FlcNavTileBox::bottom() const {
  return bottom_;
}
inline void FlcNavTileBox::set_bottom(::google::protobuf::uint32 value) {
  _set_bit(3);
  bottom_ = value;
}

// -------------------------------------------------------------------

// StringTable

// repeated string s = 1;
inline int StringTable::s_size() const {
  return s_.size();
}
inline void StringTable::clear_s() {
  s_.Clear();
}
inline const ::std::string& StringTable::s(int index) const {
  return s_.Get(index);
}
inline ::std::string* StringTable::mutable_s(int index) {
  return s_.Mutable(index);
}
inline void StringTable::set_s(int index, const ::std::string& value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringTable::add_s() {
  return s_.Add();
}
inline void StringTable::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringTable::s() const {
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringTable::mutable_s() {
  return &s_;
}

// -------------------------------------------------------------------

// IndexedStringTable

// optional string prefix = 1;
inline bool IndexedStringTable::has_prefix() const {
  return _has_bit(0);
}
inline void IndexedStringTable::clear_prefix() {
  if (prefix_ != &_default_prefix_) {
    prefix_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IndexedStringTable::prefix() const {
  return *prefix_;
}
inline void IndexedStringTable::set_prefix(const ::std::string& value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value, size_t size) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::mutable_prefix() {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}

// repeated string key = 3;
inline int IndexedStringTable::key_size() const {
  return key_.size();
}
inline void IndexedStringTable::clear_key() {
  key_.Clear();
}
inline const ::std::string& IndexedStringTable::key(int index) const {
  return key_.Get(index);
}
inline ::std::string* IndexedStringTable::mutable_key(int index) {
  return key_.Mutable(index);
}
inline void IndexedStringTable::set_key(int index, const ::std::string& value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::add_key() {
  return key_.Add();
}
inline void IndexedStringTable::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexedStringTable::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexedStringTable::mutable_key() {
  return &key_;
}

// repeated fixed32 val = 4;
inline int IndexedStringTable::val_size() const {
  return val_.size();
}
inline void IndexedStringTable::clear_val() {
  val_.Clear();
}
inline ::google::protobuf::uint32 IndexedStringTable::val(int index) const {
  return val_.Get(index);
}
inline void IndexedStringTable::set_val(int index, ::google::protobuf::uint32 value) {
  val_.Set(index, value);
}
inline void IndexedStringTable::add_val(::google::protobuf::uint32 value) {
  val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IndexedStringTable::val() const {
  return val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IndexedStringTable::mutable_val() {
  return &val_;
}

// repeated .IndexedStringTable subtables = 5;
inline int IndexedStringTable::subtables_size() const {
  return subtables_.size();
}
inline void IndexedStringTable::clear_subtables() {
  subtables_.Clear();
}
inline const ::IndexedStringTable& IndexedStringTable::subtables(int index) const {
  return subtables_.Get(index);
}
inline ::IndexedStringTable* IndexedStringTable::mutable_subtables(int index) {
  return subtables_.Mutable(index);
}
inline ::IndexedStringTable* IndexedStringTable::add_subtables() {
  return subtables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
IndexedStringTable::subtables() const {
  return subtables_;
}
inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
IndexedStringTable::mutable_subtables() {
  return &subtables_;
}

// -------------------------------------------------------------------

// FlcNavMapIndex_MapEncodingRule

// required string tag = 3;
inline bool FlcNavMapIndex_MapEncodingRule::has_tag() const {
  return _has_bit(0);
}
inline void FlcNavMapIndex_MapEncodingRule::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavMapIndex_MapEncodingRule::tag() const {
  return *tag_;
}
inline void FlcNavMapIndex_MapEncodingRule::set_tag(const ::std::string& value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FlcNavMapIndex_MapEncodingRule::set_tag(const char* value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FlcNavMapIndex_MapEncodingRule::set_tag(const char* value, size_t size) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavMapIndex_MapEncodingRule::mutable_tag() {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional string value = 5;
inline bool FlcNavMapIndex_MapEncodingRule::has_value() const {
  return _has_bit(1);
}
inline void FlcNavMapIndex_MapEncodingRule::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FlcNavMapIndex_MapEncodingRule::value() const {
  return *value_;
}
inline void FlcNavMapIndex_MapEncodingRule::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FlcNavMapIndex_MapEncodingRule::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FlcNavMapIndex_MapEncodingRule::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavMapIndex_MapEncodingRule::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional uint32 id = 7;
inline bool FlcNavMapIndex_MapEncodingRule::has_id() const {
  return _has_bit(2);
}
inline void FlcNavMapIndex_MapEncodingRule::clear_id() {
  id_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 FlcNavMapIndex_MapEncodingRule::id() const {
  return id_;
}
inline void FlcNavMapIndex_MapEncodingRule::set_id(::google::protobuf::uint32 value) {
  _set_bit(2);
  id_ = value;
}

// optional uint32 minZoom = 9;
inline bool FlcNavMapIndex_MapEncodingRule::has_minzoom() const {
  return _has_bit(3);
}
inline void FlcNavMapIndex_MapEncodingRule::clear_minzoom() {
  minzoom_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 FlcNavMapIndex_MapEncodingRule::minzoom() const {
  return minzoom_;
}
inline void FlcNavMapIndex_MapEncodingRule::set_minzoom(::google::protobuf::uint32 value) {
  _set_bit(3);
  minzoom_ = value;
}

// optional uint32 type = 10;
inline bool FlcNavMapIndex_MapEncodingRule::has_type() const {
  return _has_bit(4);
}
inline void FlcNavMapIndex_MapEncodingRule::clear_type() {
  type_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 FlcNavMapIndex_MapEncodingRule::type() const {
  return type_;
}
inline void FlcNavMapIndex_MapEncodingRule::set_type(::google::protobuf::uint32 value) {
  _set_bit(4);
  type_ = value;
}

// -------------------------------------------------------------------

// FlcNavMapIndex_MapRootLevel

// required int32 maxZoom = 1;
inline bool FlcNavMapIndex_MapRootLevel::has_maxzoom() const {
  return _has_bit(0);
}
inline void FlcNavMapIndex_MapRootLevel::clear_maxzoom() {
  maxzoom_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::maxzoom() const {
  return maxzoom_;
}
inline void FlcNavMapIndex_MapRootLevel::set_maxzoom(::google::protobuf::int32 value) {
  _set_bit(0);
  maxzoom_ = value;
}

// required int32 minZoom = 2;
inline bool FlcNavMapIndex_MapRootLevel::has_minzoom() const {
  return _has_bit(1);
}
inline void FlcNavMapIndex_MapRootLevel::clear_minzoom() {
  minzoom_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::minzoom() const {
  return minzoom_;
}
inline void FlcNavMapIndex_MapRootLevel::set_minzoom(::google::protobuf::int32 value) {
  _set_bit(1);
  minzoom_ = value;
}

// required int32 left = 3;
inline bool FlcNavMapIndex_MapRootLevel::has_left() const {
  return _has_bit(2);
}
inline void FlcNavMapIndex_MapRootLevel::clear_left() {
  left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::left() const {
  return left_;
}
inline void FlcNavMapIndex_MapRootLevel::set_left(::google::protobuf::int32 value) {
  _set_bit(2);
  left_ = value;
}

// required int32 right = 4;
inline bool FlcNavMapIndex_MapRootLevel::has_right() const {
  return _has_bit(3);
}
inline void FlcNavMapIndex_MapRootLevel::clear_right() {
  right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::right() const {
  return right_;
}
inline void FlcNavMapIndex_MapRootLevel::set_right(::google::protobuf::int32 value) {
  _set_bit(3);
  right_ = value;
}

// required int32 top = 5;
inline bool FlcNavMapIndex_MapRootLevel::has_top() const {
  return _has_bit(4);
}
inline void FlcNavMapIndex_MapRootLevel::clear_top() {
  top_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::top() const {
  return top_;
}
inline void FlcNavMapIndex_MapRootLevel::set_top(::google::protobuf::int32 value) {
  _set_bit(4);
  top_ = value;
}

// required int32 bottom = 6;
inline bool FlcNavMapIndex_MapRootLevel::has_bottom() const {
  return _has_bit(5);
}
inline void FlcNavMapIndex_MapRootLevel::clear_bottom() {
  bottom_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapRootLevel::bottom() const {
  return bottom_;
}
inline void FlcNavMapIndex_MapRootLevel::set_bottom(::google::protobuf::int32 value) {
  _set_bit(5);
  bottom_ = value;
}

// repeated .FlcNavMapIndex.MapDataBox boxes = 7;
inline int FlcNavMapIndex_MapRootLevel::boxes_size() const {
  return boxes_.size();
}
inline void FlcNavMapIndex_MapRootLevel::clear_boxes() {
  boxes_.Clear();
}
inline const ::FlcNavMapIndex_MapDataBox& FlcNavMapIndex_MapRootLevel::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::FlcNavMapIndex_MapDataBox* FlcNavMapIndex_MapRootLevel::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::FlcNavMapIndex_MapDataBox* FlcNavMapIndex_MapRootLevel::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >&
FlcNavMapIndex_MapRootLevel::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >*
FlcNavMapIndex_MapRootLevel::mutable_boxes() {
  return &boxes_;
}

// repeated .MapDataBlock blocks = 15;
inline int FlcNavMapIndex_MapRootLevel::blocks_size() const {
  return blocks_.size();
}
inline void FlcNavMapIndex_MapRootLevel::clear_blocks() {
  blocks_.Clear();
}
inline const ::MapDataBlock& FlcNavMapIndex_MapRootLevel::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::MapDataBlock* FlcNavMapIndex_MapRootLevel::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::MapDataBlock* FlcNavMapIndex_MapRootLevel::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataBlock >&
FlcNavMapIndex_MapRootLevel::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataBlock >*
FlcNavMapIndex_MapRootLevel::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// FlcNavMapIndex_MapDataBox

// required sint32 left = 1;
inline bool FlcNavMapIndex_MapDataBox::has_left() const {
  return _has_bit(0);
}
inline void FlcNavMapIndex_MapDataBox::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapDataBox::left() const {
  return left_;
}
inline void FlcNavMapIndex_MapDataBox::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool FlcNavMapIndex_MapDataBox::has_right() const {
  return _has_bit(1);
}
inline void FlcNavMapIndex_MapDataBox::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapDataBox::right() const {
  return right_;
}
inline void FlcNavMapIndex_MapDataBox::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool FlcNavMapIndex_MapDataBox::has_top() const {
  return _has_bit(2);
}
inline void FlcNavMapIndex_MapDataBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapDataBox::top() const {
  return top_;
}
inline void FlcNavMapIndex_MapDataBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool FlcNavMapIndex_MapDataBox::has_bottom() const {
  return _has_bit(3);
}
inline void FlcNavMapIndex_MapDataBox::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 FlcNavMapIndex_MapDataBox::bottom() const {
  return bottom_;
}
inline void FlcNavMapIndex_MapDataBox::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// optional fixed32 shiftToMapData = 5;
inline bool FlcNavMapIndex_MapDataBox::has_shifttomapdata() const {
  return _has_bit(4);
}
inline void FlcNavMapIndex_MapDataBox::clear_shifttomapdata() {
  shifttomapdata_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 FlcNavMapIndex_MapDataBox::shifttomapdata() const {
  return shifttomapdata_;
}
inline void FlcNavMapIndex_MapDataBox::set_shifttomapdata(::google::protobuf::uint32 value) {
  _set_bit(4);
  shifttomapdata_ = value;
}

// optional bool ocean = 6;
inline bool FlcNavMapIndex_MapDataBox::has_ocean() const {
  return _has_bit(5);
}
inline void FlcNavMapIndex_MapDataBox::clear_ocean() {
  ocean_ = false;
  _clear_bit(5);
}
inline bool FlcNavMapIndex_MapDataBox::ocean() const {
  return ocean_;
}
inline void FlcNavMapIndex_MapDataBox::set_ocean(bool value) {
  _set_bit(5);
  ocean_ = value;
}

// repeated .FlcNavMapIndex.MapDataBox boxes = 7;
inline int FlcNavMapIndex_MapDataBox::boxes_size() const {
  return boxes_.size();
}
inline void FlcNavMapIndex_MapDataBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::FlcNavMapIndex_MapDataBox& FlcNavMapIndex_MapDataBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::FlcNavMapIndex_MapDataBox* FlcNavMapIndex_MapDataBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::FlcNavMapIndex_MapDataBox* FlcNavMapIndex_MapDataBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >&
FlcNavMapIndex_MapDataBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapDataBox >*
FlcNavMapIndex_MapDataBox::mutable_boxes() {
  return &boxes_;
}

// -------------------------------------------------------------------

// FlcNavMapIndex

// required string name = 2;
inline bool FlcNavMapIndex::has_name() const {
  return _has_bit(0);
}
inline void FlcNavMapIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavMapIndex::name() const {
  return *name_;
}
inline void FlcNavMapIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavMapIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavMapIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavMapIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .FlcNavMapIndex.MapEncodingRule rules = 4;
inline int FlcNavMapIndex::rules_size() const {
  return rules_.size();
}
inline void FlcNavMapIndex::clear_rules() {
  rules_.Clear();
}
inline const ::FlcNavMapIndex_MapEncodingRule& FlcNavMapIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::FlcNavMapIndex_MapEncodingRule* FlcNavMapIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::FlcNavMapIndex_MapEncodingRule* FlcNavMapIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapEncodingRule >&
FlcNavMapIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapEncodingRule >*
FlcNavMapIndex::mutable_rules() {
  return &rules_;
}

// repeated .FlcNavMapIndex.MapRootLevel levels = 5;
inline int FlcNavMapIndex::levels_size() const {
  return levels_.size();
}
inline void FlcNavMapIndex::clear_levels() {
  levels_.Clear();
}
inline const ::FlcNavMapIndex_MapRootLevel& FlcNavMapIndex::levels(int index) const {
  return levels_.Get(index);
}
inline ::FlcNavMapIndex_MapRootLevel* FlcNavMapIndex::mutable_levels(int index) {
  return levels_.Mutable(index);
}
inline ::FlcNavMapIndex_MapRootLevel* FlcNavMapIndex::add_levels() {
  return levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapRootLevel >&
FlcNavMapIndex::levels() const {
  return levels_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavMapIndex_MapRootLevel >*
FlcNavMapIndex::mutable_levels() {
  return &levels_;
}

// -------------------------------------------------------------------

// MapDataBlock

// optional uint64 baseId = 10;
inline bool MapDataBlock::has_baseid() const {
  return _has_bit(0);
}
inline void MapDataBlock::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 MapDataBlock::baseid() const {
  return baseid_;
}
inline void MapDataBlock::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(0);
  baseid_ = value;
}

// repeated .MapData dataObjects = 12;
inline int MapDataBlock::dataobjects_size() const {
  return dataobjects_.size();
}
inline void MapDataBlock::clear_dataobjects() {
  dataobjects_.Clear();
}
inline const ::MapData& MapDataBlock::dataobjects(int index) const {
  return dataobjects_.Get(index);
}
inline ::MapData* MapDataBlock::mutable_dataobjects(int index) {
  return dataobjects_.Mutable(index);
}
inline ::MapData* MapDataBlock::add_dataobjects() {
  return dataobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
MapDataBlock::dataobjects() const {
  return dataobjects_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapData >*
MapDataBlock::mutable_dataobjects() {
  return &dataobjects_;
}

// optional .StringTable stringTable = 15;
inline bool MapDataBlock::has_stringtable() const {
  return _has_bit(2);
}
inline void MapDataBlock::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(2);
}
inline const ::StringTable& MapDataBlock::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* MapDataBlock::mutable_stringtable() {
  _set_bit(2);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// MapData

// optional bytes coordinates = 1;
inline bool MapData::has_coordinates() const {
  return _has_bit(0);
}
inline void MapData::clear_coordinates() {
  if (coordinates_ != &_default_coordinates_) {
    coordinates_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MapData::coordinates() const {
  return *coordinates_;
}
inline void MapData::set_coordinates(const ::std::string& value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const char* value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const void* value, size_t size) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_coordinates() {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  return coordinates_;
}

// optional bytes areaCoordinates = 2;
inline bool MapData::has_areacoordinates() const {
  return _has_bit(1);
}
inline void MapData::clear_areacoordinates() {
  if (areacoordinates_ != &_default_areacoordinates_) {
    areacoordinates_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MapData::areacoordinates() const {
  return *areacoordinates_;
}
inline void MapData::set_areacoordinates(const ::std::string& value) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const char* value) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const void* value, size_t size) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_areacoordinates() {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  return areacoordinates_;
}

// repeated bytes polygonInnerCoordinates = 4;
inline int MapData::polygoninnercoordinates_size() const {
  return polygoninnercoordinates_.size();
}
inline void MapData::clear_polygoninnercoordinates() {
  polygoninnercoordinates_.Clear();
}
inline const ::std::string& MapData::polygoninnercoordinates(int index) const {
  return polygoninnercoordinates_.Get(index);
}
inline ::std::string* MapData::mutable_polygoninnercoordinates(int index) {
  return polygoninnercoordinates_.Mutable(index);
}
inline void MapData::set_polygoninnercoordinates(int index, const ::std::string& value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const char* value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const void* value, size_t size) {
  polygoninnercoordinates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::add_polygoninnercoordinates() {
  return polygoninnercoordinates_.Add();
}
inline void MapData::add_polygoninnercoordinates(const ::std::string& value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const char* value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const void* value, size_t size) {
  polygoninnercoordinates_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapData::polygoninnercoordinates() const {
  return polygoninnercoordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapData::mutable_polygoninnercoordinates() {
  return &polygoninnercoordinates_;
}

// optional bytes additionalTypes = 6;
inline bool MapData::has_additionaltypes() const {
  return _has_bit(3);
}
inline void MapData::clear_additionaltypes() {
  if (additionaltypes_ != &_default_additionaltypes_) {
    additionaltypes_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& MapData::additionaltypes() const {
  return *additionaltypes_;
}
inline void MapData::set_additionaltypes(const ::std::string& value) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const char* value) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const void* value, size_t size) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_additionaltypes() {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  return additionaltypes_;
}

// required bytes types = 7;
inline bool MapData::has_types() const {
  return _has_bit(4);
}
inline void MapData::clear_types() {
  if (types_ != &_default_types_) {
    types_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MapData::types() const {
  return *types_;
}
inline void MapData::set_types(const ::std::string& value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const char* value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const void* value, size_t size) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_types() {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  return types_;
}

// optional bytes stringNames = 10;
inline bool MapData::has_stringnames() const {
  return _has_bit(5);
}
inline void MapData::clear_stringnames() {
  if (stringnames_ != &_default_stringnames_) {
    stringnames_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& MapData::stringnames() const {
  return *stringnames_;
}
inline void MapData::set_stringnames(const ::std::string& value) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const char* value) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const void* value, size_t size) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_stringnames() {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  return stringnames_;
}

// required sint64 id = 12;
inline bool MapData::has_id() const {
  return _has_bit(6);
}
inline void MapData::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::int64 MapData::id() const {
  return id_;
}
inline void MapData::set_id(::google::protobuf::int64 value) {
  _set_bit(6);
  id_ = value;
}

// optional bytes rasterBytes = 15;
inline bool MapData::has_rasterbytes() const {
  return _has_bit(7);
}
inline void MapData::clear_rasterbytes() {
  if (rasterbytes_ != &_default_rasterbytes_) {
    rasterbytes_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& MapData::rasterbytes() const {
  return *rasterbytes_;
}
inline void MapData::set_rasterbytes(const ::std::string& value) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const char* value) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const void* value, size_t size) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_rasterbytes() {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  return rasterbytes_;
}

// -------------------------------------------------------------------

// FlcNavAddressIndex_CitiesIndex

// required uint32 type = 2;
inline bool FlcNavAddressIndex_CitiesIndex::has_type() const {
  return _has_bit(0);
}
inline void FlcNavAddressIndex_CitiesIndex::clear_type() {
  type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavAddressIndex_CitiesIndex::type() const {
  return type_;
}
inline void FlcNavAddressIndex_CitiesIndex::set_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  type_ = value;
}

// repeated .CityIndex cities = 5;
inline int FlcNavAddressIndex_CitiesIndex::cities_size() const {
  return cities_.size();
}
inline void FlcNavAddressIndex_CitiesIndex::clear_cities() {
  cities_.Clear();
}
inline const ::CityIndex& FlcNavAddressIndex_CitiesIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::CityIndex* FlcNavAddressIndex_CitiesIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::CityIndex* FlcNavAddressIndex_CitiesIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
FlcNavAddressIndex_CitiesIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
FlcNavAddressIndex_CitiesIndex::mutable_cities() {
  return &cities_;
}

// repeated .CityBlockIndex blocks = 7;
inline int FlcNavAddressIndex_CitiesIndex::blocks_size() const {
  return blocks_.size();
}
inline void FlcNavAddressIndex_CitiesIndex::clear_blocks() {
  blocks_.Clear();
}
inline const ::CityBlockIndex& FlcNavAddressIndex_CitiesIndex::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::CityBlockIndex* FlcNavAddressIndex_CitiesIndex::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::CityBlockIndex* FlcNavAddressIndex_CitiesIndex::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >&
FlcNavAddressIndex_CitiesIndex::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >*
FlcNavAddressIndex_CitiesIndex::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// FlcNavAddressIndex

// required string name = 1;
inline bool FlcNavAddressIndex::has_name() const {
  return _has_bit(0);
}
inline void FlcNavAddressIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavAddressIndex::name() const {
  return *name_;
}
inline void FlcNavAddressIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavAddressIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavAddressIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavAddressIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool FlcNavAddressIndex::has_name_en() const {
  return _has_bit(1);
}
inline void FlcNavAddressIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FlcNavAddressIndex::name_en() const {
  return *name_en_;
}
inline void FlcNavAddressIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void FlcNavAddressIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void FlcNavAddressIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavAddressIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional .FlcNavTileBox boundaries = 3;
inline bool FlcNavAddressIndex::has_boundaries() const {
  return _has_bit(2);
}
inline void FlcNavAddressIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::FlcNavTileBox::Clear();
  _clear_bit(2);
}
inline const ::FlcNavTileBox& FlcNavAddressIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::FlcNavTileBox* FlcNavAddressIndex::mutable_boundaries() {
  _set_bit(2);
  if (boundaries_ == NULL) boundaries_ = new ::FlcNavTileBox;
  return boundaries_;
}

// repeated .FlcNavAddressIndex.CitiesIndex cities = 6;
inline int FlcNavAddressIndex::cities_size() const {
  return cities_.size();
}
inline void FlcNavAddressIndex::clear_cities() {
  cities_.Clear();
}
inline const ::FlcNavAddressIndex_CitiesIndex& FlcNavAddressIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::FlcNavAddressIndex_CitiesIndex* FlcNavAddressIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::FlcNavAddressIndex_CitiesIndex* FlcNavAddressIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex_CitiesIndex >&
FlcNavAddressIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressIndex_CitiesIndex >*
FlcNavAddressIndex::mutable_cities() {
  return &cities_;
}

// optional .FlcNavAddressNameIndexData nameIndex = 7;
inline bool FlcNavAddressIndex::has_nameindex() const {
  return _has_bit(4);
}
inline void FlcNavAddressIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::FlcNavAddressNameIndexData::Clear();
  _clear_bit(4);
}
inline const ::FlcNavAddressNameIndexData& FlcNavAddressIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::FlcNavAddressNameIndexData* FlcNavAddressIndex::mutable_nameindex() {
  _set_bit(4);
  if (nameindex_ == NULL) nameindex_ = new ::FlcNavAddressNameIndexData;
  return nameindex_;
}

// -------------------------------------------------------------------

// FlcNavAddressNameIndexData_AddressNameIndexData

// repeated .AddressNameIndexDataAtom atom = 4;
inline int FlcNavAddressNameIndexData_AddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void FlcNavAddressNameIndexData_AddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::AddressNameIndexDataAtom& FlcNavAddressNameIndexData_AddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::AddressNameIndexDataAtom* FlcNavAddressNameIndexData_AddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::AddressNameIndexDataAtom* FlcNavAddressNameIndexData_AddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >&
FlcNavAddressNameIndexData_AddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >*
FlcNavAddressNameIndexData_AddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// FlcNavAddressNameIndexData

// required .IndexedStringTable table = 4;
inline bool FlcNavAddressNameIndexData::has_table() const {
  return _has_bit(0);
}
inline void FlcNavAddressNameIndexData::clear_table() {
  if (table_ != NULL) table_->::IndexedStringTable::Clear();
  _clear_bit(0);
}
inline const ::IndexedStringTable& FlcNavAddressNameIndexData::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::IndexedStringTable* FlcNavAddressNameIndexData::mutable_table() {
  _set_bit(0);
  if (table_ == NULL) table_ = new ::IndexedStringTable;
  return table_;
}

// repeated .FlcNavAddressNameIndexData.AddressNameIndexData atom = 7;
inline int FlcNavAddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void FlcNavAddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::FlcNavAddressNameIndexData_AddressNameIndexData& FlcNavAddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::FlcNavAddressNameIndexData_AddressNameIndexData* FlcNavAddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::FlcNavAddressNameIndexData_AddressNameIndexData* FlcNavAddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavAddressNameIndexData_AddressNameIndexData >&
FlcNavAddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavAddressNameIndexData_AddressNameIndexData >*
FlcNavAddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// AddressNameIndexDataAtom

// optional string name = 1;
inline bool AddressNameIndexDataAtom::has_name() const {
  return _has_bit(0);
}
inline void AddressNameIndexDataAtom::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AddressNameIndexDataAtom::name() const {
  return *name_;
}
inline void AddressNameIndexDataAtom::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string nameEn = 2;
inline bool AddressNameIndexDataAtom::has_nameen() const {
  return _has_bit(1);
}
inline void AddressNameIndexDataAtom::clear_nameen() {
  if (nameen_ != &_default_nameen_) {
    nameen_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddressNameIndexDataAtom::nameen() const {
  return *nameen_;
}
inline void AddressNameIndexDataAtom::set_nameen(const ::std::string& value) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value, size_t size) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_nameen() {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}

// required uint32 type = 3;
inline bool AddressNameIndexDataAtom::has_type() const {
  return _has_bit(2);
}
inline void AddressNameIndexDataAtom::clear_type() {
  type_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 AddressNameIndexDataAtom::type() const {
  return type_;
}
inline void AddressNameIndexDataAtom::set_type(::google::protobuf::uint32 value) {
  _set_bit(2);
  type_ = value;
}

// repeated int32 shiftToIndex = 5;
inline int AddressNameIndexDataAtom::shifttoindex_size() const {
  return shifttoindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttoindex() {
  shifttoindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttoindex(int index) const {
  return shifttoindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttoindex(int index, ::google::protobuf::int32 value) {
  shifttoindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttoindex(::google::protobuf::int32 value) {
  shifttoindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttoindex() const {
  return shifttoindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttoindex() {
  return &shifttoindex_;
}

// repeated int32 shiftToCityIndex = 6;
inline int AddressNameIndexDataAtom::shifttocityindex_size() const {
  return shifttocityindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttocityindex() {
  shifttocityindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttocityindex(int index) const {
  return shifttocityindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttocityindex(int index, ::google::protobuf::int32 value) {
  shifttocityindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttocityindex(::google::protobuf::int32 value) {
  shifttocityindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttocityindex() const {
  return shifttocityindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttocityindex() {
  return &shifttocityindex_;
}

// -------------------------------------------------------------------

// CityIndex

// optional uint32 city_type = 1;
inline bool CityIndex::has_city_type() const {
  return _has_bit(0);
}
inline void CityIndex::clear_city_type() {
  city_type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CityIndex::city_type() const {
  return city_type_;
}
inline void CityIndex::set_city_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  city_type_ = value;
}

// required string name = 2;
inline bool CityIndex::has_name() const {
  return _has_bit(1);
}
inline void CityIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CityIndex::name() const {
  return *name_;
}
inline void CityIndex::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 3;
inline bool CityIndex::has_name_en() const {
  return _has_bit(2);
}
inline void CityIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CityIndex::name_en() const {
  return *name_en_;
}
inline void CityIndex::set_name_en(const ::std::string& value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value, size_t size) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name_en() {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional uint64 id = 4;
inline bool CityIndex::has_id() const {
  return _has_bit(3);
}
inline void CityIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 CityIndex::id() const {
  return id_;
}
inline void CityIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(3);
  id_ = value;
}

// required uint32 x = 5;
inline bool CityIndex::has_x() const {
  return _has_bit(4);
}
inline void CityIndex::clear_x() {
  x_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 CityIndex::x() const {
  return x_;
}
inline void CityIndex::set_x(::google::protobuf::uint32 value) {
  _set_bit(4);
  x_ = value;
}

// required uint32 y = 6;
inline bool CityIndex::has_y() const {
  return _has_bit(5);
}
inline void CityIndex::clear_y() {
  y_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 CityIndex::y() const {
  return y_;
}
inline void CityIndex::set_y(::google::protobuf::uint32 value) {
  _set_bit(5);
  y_ = value;
}

// optional fixed32 shiftToCityBlockIndex = 10;
inline bool CityIndex::has_shifttocityblockindex() const {
  return _has_bit(6);
}
inline void CityIndex::clear_shifttocityblockindex() {
  shifttocityblockindex_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 CityIndex::shifttocityblockindex() const {
  return shifttocityblockindex_;
}
inline void CityIndex::set_shifttocityblockindex(::google::protobuf::uint32 value) {
  _set_bit(6);
  shifttocityblockindex_ = value;
}

// -------------------------------------------------------------------

// CityBlockIndex

// optional fixed32 shiftToCityIndex = 4;
inline bool CityBlockIndex::has_shifttocityindex() const {
  return _has_bit(0);
}
inline void CityBlockIndex::clear_shifttocityindex() {
  shifttocityindex_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CityBlockIndex::shifttocityindex() const {
  return shifttocityindex_;
}
inline void CityBlockIndex::set_shifttocityindex(::google::protobuf::uint32 value) {
  _set_bit(0);
  shifttocityindex_ = value;
}

// repeated .BuildingIndex buildings = 10;
inline int CityBlockIndex::buildings_size() const {
  return buildings_.size();
}
inline void CityBlockIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::BuildingIndex& CityBlockIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::BuildingIndex* CityBlockIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::BuildingIndex* CityBlockIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
CityBlockIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
CityBlockIndex::mutable_buildings() {
  return &buildings_;
}

// repeated .StreetIndex streets = 12;
inline int CityBlockIndex::streets_size() const {
  return streets_.size();
}
inline void CityBlockIndex::clear_streets() {
  streets_.Clear();
}
inline const ::StreetIndex& CityBlockIndex::streets(int index) const {
  return streets_.Get(index);
}
inline ::StreetIndex* CityBlockIndex::mutable_streets(int index) {
  return streets_.Mutable(index);
}
inline ::StreetIndex* CityBlockIndex::add_streets() {
  return streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
CityBlockIndex::streets() const {
  return streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
CityBlockIndex::mutable_streets() {
  return &streets_;
}

// -------------------------------------------------------------------

// StreetIndex

// required string name = 1;
inline bool StreetIndex::has_name() const {
  return _has_bit(0);
}
inline void StreetIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StreetIndex::name() const {
  return *name_;
}
inline void StreetIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool StreetIndex::has_name_en() const {
  return _has_bit(1);
}
inline void StreetIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StreetIndex::name_en() const {
  return *name_en_;
}
inline void StreetIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// required sint32 x = 3;
inline bool StreetIndex::has_x() const {
  return _has_bit(2);
}
inline void StreetIndex::clear_x() {
  x_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIndex::x() const {
  return x_;
}
inline void StreetIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(2);
  x_ = value;
}

// required sint32 y = 4;
inline bool StreetIndex::has_y() const {
  return _has_bit(3);
}
inline void StreetIndex::clear_y() {
  y_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIndex::y() const {
  return y_;
}
inline void StreetIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(3);
  y_ = value;
}

// optional uint64 id = 6;
inline bool StreetIndex::has_id() const {
  return _has_bit(4);
}
inline void StreetIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 StreetIndex::id() const {
  return id_;
}
inline void StreetIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(4);
  id_ = value;
}

// repeated .BuildingIndex buildings = 12;
inline int StreetIndex::buildings_size() const {
  return buildings_.size();
}
inline void StreetIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::BuildingIndex& StreetIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::BuildingIndex* StreetIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::BuildingIndex* StreetIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
StreetIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
StreetIndex::mutable_buildings() {
  return &buildings_;
}

// repeated .StreetIntersection intersections = 5;
inline int StreetIndex::intersections_size() const {
  return intersections_.size();
}
inline void StreetIndex::clear_intersections() {
  intersections_.Clear();
}
inline const ::StreetIntersection& StreetIndex::intersections(int index) const {
  return intersections_.Get(index);
}
inline ::StreetIntersection* StreetIndex::mutable_intersections(int index) {
  return intersections_.Mutable(index);
}
inline ::StreetIntersection* StreetIndex::add_intersections() {
  return intersections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
StreetIndex::intersections() const {
  return intersections_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
StreetIndex::mutable_intersections() {
  return &intersections_;
}

// -------------------------------------------------------------------

// StreetIntersection

// required string name = 2;
inline bool StreetIntersection::has_name() const {
  return _has_bit(0);
}
inline void StreetIntersection::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StreetIntersection::name() const {
  return *name_;
}
inline void StreetIntersection::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 3;
inline bool StreetIntersection::has_name_en() const {
  return _has_bit(1);
}
inline void StreetIntersection::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StreetIntersection::name_en() const {
  return *name_en_;
}
inline void StreetIntersection::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// required sint32 intersectedX = 4;
inline bool StreetIntersection::has_intersectedx() const {
  return _has_bit(2);
}
inline void StreetIntersection::clear_intersectedx() {
  intersectedx_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedx() const {
  return intersectedx_;
}
inline void StreetIntersection::set_intersectedx(::google::protobuf::int32 value) {
  _set_bit(2);
  intersectedx_ = value;
}

// required sint32 intersectedY = 5;
inline bool StreetIntersection::has_intersectedy() const {
  return _has_bit(3);
}
inline void StreetIntersection::clear_intersectedy() {
  intersectedy_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedy() const {
  return intersectedy_;
}
inline void StreetIntersection::set_intersectedy(::google::protobuf::int32 value) {
  _set_bit(3);
  intersectedy_ = value;
}

// -------------------------------------------------------------------

// BuildingIndex

// required string name = 1;
inline bool BuildingIndex::has_name() const {
  return _has_bit(0);
}
inline void BuildingIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BuildingIndex::name() const {
  return *name_;
}
inline void BuildingIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool BuildingIndex::has_name_en() const {
  return _has_bit(1);
}
inline void BuildingIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BuildingIndex::name_en() const {
  return *name_en_;
}
inline void BuildingIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional string name2 = 3;
inline bool BuildingIndex::has_name2() const {
  return _has_bit(2);
}
inline void BuildingIndex::clear_name2() {
  if (name2_ != &_default_name2_) {
    name2_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BuildingIndex::name2() const {
  return *name2_;
}
inline void BuildingIndex::set_name2(const ::std::string& value) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value, size_t size) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name2() {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  return name2_;
}

// optional string name_en2 = 4;
inline bool BuildingIndex::has_name_en2() const {
  return _has_bit(3);
}
inline void BuildingIndex::clear_name_en2() {
  if (name_en2_ != &_default_name_en2_) {
    name_en2_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BuildingIndex::name_en2() const {
  return *name_en2_;
}
inline void BuildingIndex::set_name_en2(const ::std::string& value) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value, size_t size) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en2() {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  return name_en2_;
}

// optional sint32 interpolation = 5;
inline bool BuildingIndex::has_interpolation() const {
  return _has_bit(4);
}
inline void BuildingIndex::clear_interpolation() {
  interpolation_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 BuildingIndex::interpolation() const {
  return interpolation_;
}
inline void BuildingIndex::set_interpolation(::google::protobuf::int32 value) {
  _set_bit(4);
  interpolation_ = value;
}

// required sint32 x = 7;
inline bool BuildingIndex::has_x() const {
  return _has_bit(5);
}
inline void BuildingIndex::clear_x() {
  x_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 BuildingIndex::x() const {
  return x_;
}
inline void BuildingIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(5);
  x_ = value;
}

// required sint32 y = 8;
inline bool BuildingIndex::has_y() const {
  return _has_bit(6);
}
inline void BuildingIndex::clear_y() {
  y_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 BuildingIndex::y() const {
  return y_;
}
inline void BuildingIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(6);
  y_ = value;
}

// optional sint32 x2 = 9;
inline bool BuildingIndex::has_x2() const {
  return _has_bit(7);
}
inline void BuildingIndex::clear_x2() {
  x2_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 BuildingIndex::x2() const {
  return x2_;
}
inline void BuildingIndex::set_x2(::google::protobuf::int32 value) {
  _set_bit(7);
  x2_ = value;
}

// optional sint32 y2 = 10;
inline bool BuildingIndex::has_y2() const {
  return _has_bit(8);
}
inline void BuildingIndex::clear_y2() {
  y2_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 BuildingIndex::y2() const {
  return y2_;
}
inline void BuildingIndex::set_y2(::google::protobuf::int32 value) {
  _set_bit(8);
  y2_ = value;
}

// optional uint64 id = 13;
inline bool BuildingIndex::has_id() const {
  return _has_bit(9);
}
inline void BuildingIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(9);
}
inline ::google::protobuf::uint64 BuildingIndex::id() const {
  return id_;
}
inline void BuildingIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(9);
  id_ = value;
}

// optional string postcode = 14;
inline bool BuildingIndex::has_postcode() const {
  return _has_bit(10);
}
inline void BuildingIndex::clear_postcode() {
  if (postcode_ != &_default_postcode_) {
    postcode_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& BuildingIndex::postcode() const {
  return *postcode_;
}
inline void BuildingIndex::set_postcode(const ::std::string& value) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value, size_t size) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_postcode() {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}

// -------------------------------------------------------------------

// TransportRoutes

// repeated .TransportRoute routes = 6;
inline int TransportRoutes::routes_size() const {
  return routes_.size();
}
inline void TransportRoutes::clear_routes() {
  routes_.Clear();
}
inline const ::TransportRoute& TransportRoutes::routes(int index) const {
  return routes_.Get(index);
}
inline ::TransportRoute* TransportRoutes::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::TransportRoute* TransportRoutes::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
TransportRoutes::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
TransportRoutes::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportRoute

// required uint64 id = 1;
inline bool TransportRoute::has_id() const {
  return _has_bit(0);
}
inline void TransportRoute::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 TransportRoute::id() const {
  return id_;
}
inline void TransportRoute::set_id(::google::protobuf::uint64 value) {
  _set_bit(0);
  id_ = value;
}

// optional uint32 type = 3;
inline bool TransportRoute::has_type() const {
  return _has_bit(1);
}
inline void TransportRoute::clear_type() {
  type_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 TransportRoute::type() const {
  return type_;
}
inline void TransportRoute::set_type(::google::protobuf::uint32 value) {
  _set_bit(1);
  type_ = value;
}

// optional uint32 operator = 4;
inline bool TransportRoute::has_operator_() const {
  return _has_bit(2);
}
inline void TransportRoute::clear_operator_() {
  operator__ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 TransportRoute::operator_() const {
  return operator__;
}
inline void TransportRoute::set_operator_(::google::protobuf::uint32 value) {
  _set_bit(2);
  operator__ = value;
}

// optional string ref = 5;
inline bool TransportRoute::has_ref() const {
  return _has_bit(3);
}
inline void TransportRoute::clear_ref() {
  if (ref_ != &_default_ref_) {
    ref_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& TransportRoute::ref() const {
  return *ref_;
}
inline void TransportRoute::set_ref(const ::std::string& value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value, size_t size) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::mutable_ref() {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  return ref_;
}

// optional uint32 name = 6;
inline bool TransportRoute::has_name() const {
  return _has_bit(4);
}
inline void TransportRoute::clear_name() {
  name_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRoute::name() const {
  return name_;
}
inline void TransportRoute::set_name(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRoute::has_name_en() const {
  return _has_bit(5);
}
inline void TransportRoute::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 TransportRoute::name_en() const {
  return name_en_;
}
inline void TransportRoute::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(5);
  name_en_ = value;
}

// optional uint32 distance = 8;
inline bool TransportRoute::has_distance() const {
  return _has_bit(6);
}
inline void TransportRoute::clear_distance() {
  distance_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 TransportRoute::distance() const {
  return distance_;
}
inline void TransportRoute::set_distance(::google::protobuf::uint32 value) {
  _set_bit(6);
  distance_ = value;
}

// repeated .TransportRouteStop directStops = 15;
inline int TransportRoute::directstops_size() const {
  return directstops_.size();
}
inline void TransportRoute::clear_directstops() {
  directstops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::directstops(int index) const {
  return directstops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_directstops(int index) {
  return directstops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_directstops() {
  return directstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::directstops() const {
  return directstops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_directstops() {
  return &directstops_;
}

// repeated .TransportRouteStop reverseStops = 16;
inline int TransportRoute::reversestops_size() const {
  return reversestops_.size();
}
inline void TransportRoute::clear_reversestops() {
  reversestops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::reversestops(int index) const {
  return reversestops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_reversestops(int index) {
  return reversestops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_reversestops() {
  return reversestops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::reversestops() const {
  return reversestops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_reversestops() {
  return &reversestops_;
}

// -------------------------------------------------------------------

// TransportRouteStop

// required sint64 id = 1;
inline bool TransportRouteStop::has_id() const {
  return _has_bit(0);
}
inline void TransportRouteStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 TransportRouteStop::id() const {
  return id_;
}
inline void TransportRouteStop::set_id(::google::protobuf::int64 value) {
  _set_bit(0);
  id_ = value;
}

// required sint32 dx = 2;
inline bool TransportRouteStop::has_dx() const {
  return _has_bit(1);
}
inline void TransportRouteStop::clear_dx() {
  dx_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportRouteStop::dx() const {
  return dx_;
}
inline void TransportRouteStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(1);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool TransportRouteStop::has_dy() const {
  return _has_bit(2);
}
inline void TransportRouteStop::clear_dy() {
  dy_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportRouteStop::dy() const {
  return dy_;
}
inline void TransportRouteStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(2);
  dy_ = value;
}

// required uint32 name = 6;
inline bool TransportRouteStop::has_name() const {
  return _has_bit(3);
}
inline void TransportRouteStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportRouteStop::name() const {
  return name_;
}
inline void TransportRouteStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRouteStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportRouteStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRouteStop::name_en() const {
  return name_en_;
}
inline void TransportRouteStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// -------------------------------------------------------------------

// TransportStop

// required sint32 dx = 1;
inline bool TransportStop::has_dx() const {
  return _has_bit(0);
}
inline void TransportStop::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStop::dx() const {
  return dx_;
}
inline void TransportStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 2;
inline bool TransportStop::has_dy() const {
  return _has_bit(1);
}
inline void TransportStop::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStop::dy() const {
  return dy_;
}
inline void TransportStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// required sint64 id = 5;
inline bool TransportStop::has_id() const {
  return _has_bit(2);
}
inline void TransportStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TransportStop::id() const {
  return id_;
}
inline void TransportStop::set_id(::google::protobuf::int64 value) {
  _set_bit(2);
  id_ = value;
}

// required uint32 name = 6;
inline bool TransportStop::has_name() const {
  return _has_bit(3);
}
inline void TransportStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportStop::name() const {
  return name_;
}
inline void TransportStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportStop::name_en() const {
  return name_en_;
}
inline void TransportStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// repeated uint32 routes = 16;
inline int TransportStop::routes_size() const {
  return routes_.size();
}
inline void TransportStop::clear_routes() {
  routes_.Clear();
}
inline ::google::protobuf::uint32 TransportStop::routes(int index) const {
  return routes_.Get(index);
}
inline void TransportStop::set_routes(int index, ::google::protobuf::uint32 value) {
  routes_.Set(index, value);
}
inline void TransportStop::add_routes(::google::protobuf::uint32 value) {
  routes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportStop::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportStop::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportStopsTree

// required sint32 left = 1;
inline bool TransportStopsTree::has_left() const {
  return _has_bit(0);
}
inline void TransportStopsTree::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStopsTree::left() const {
  return left_;
}
inline void TransportStopsTree::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool TransportStopsTree::has_right() const {
  return _has_bit(1);
}
inline void TransportStopsTree::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStopsTree::right() const {
  return right_;
}
inline void TransportStopsTree::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool TransportStopsTree::has_top() const {
  return _has_bit(2);
}
inline void TransportStopsTree::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportStopsTree::top() const {
  return top_;
}
inline void TransportStopsTree::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool TransportStopsTree::has_bottom() const {
  return _has_bit(3);
}
inline void TransportStopsTree::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 TransportStopsTree::bottom() const {
  return bottom_;
}
inline void TransportStopsTree::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// repeated .TransportStopsTree subtrees = 7;
inline int TransportStopsTree::subtrees_size() const {
  return subtrees_.size();
}
inline void TransportStopsTree::clear_subtrees() {
  subtrees_.Clear();
}
inline const ::TransportStopsTree& TransportStopsTree::subtrees(int index) const {
  return subtrees_.Get(index);
}
inline ::TransportStopsTree* TransportStopsTree::mutable_subtrees(int index) {
  return subtrees_.Mutable(index);
}
inline ::TransportStopsTree* TransportStopsTree::add_subtrees() {
  return subtrees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
TransportStopsTree::subtrees() const {
  return subtrees_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
TransportStopsTree::mutable_subtrees() {
  return &subtrees_;
}

// repeated .TransportStop leafs = 8;
inline int TransportStopsTree::leafs_size() const {
  return leafs_.size();
}
inline void TransportStopsTree::clear_leafs() {
  leafs_.Clear();
}
inline const ::TransportStop& TransportStopsTree::leafs(int index) const {
  return leafs_.Get(index);
}
inline ::TransportStop* TransportStopsTree::mutable_leafs(int index) {
  return leafs_.Mutable(index);
}
inline ::TransportStop* TransportStopsTree::add_leafs() {
  return leafs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
TransportStopsTree::leafs() const {
  return leafs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
TransportStopsTree::mutable_leafs() {
  return &leafs_;
}

// optional uint64 baseId = 16;
inline bool TransportStopsTree::has_baseid() const {
  return _has_bit(6);
}
inline void TransportStopsTree::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 TransportStopsTree::baseid() const {
  return baseid_;
}
inline void TransportStopsTree::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(6);
  baseid_ = value;
}

// -------------------------------------------------------------------

// FlcNavTransportIndex

// optional string name = 1;
inline bool FlcNavTransportIndex::has_name() const {
  return _has_bit(0);
}
inline void FlcNavTransportIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavTransportIndex::name() const {
  return *name_;
}
inline void FlcNavTransportIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavTransportIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavTransportIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavTransportIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .TransportRoutes routes = 3;
inline bool FlcNavTransportIndex::has_routes() const {
  return _has_bit(1);
}
inline void FlcNavTransportIndex::clear_routes() {
  if (routes_ != NULL) routes_->::TransportRoutes::Clear();
  _clear_bit(1);
}
inline const ::TransportRoutes& FlcNavTransportIndex::routes() const {
  return routes_ != NULL ? *routes_ : *default_instance_->routes_;
}
inline ::TransportRoutes* FlcNavTransportIndex::mutable_routes() {
  _set_bit(1);
  if (routes_ == NULL) routes_ = new ::TransportRoutes;
  return routes_;
}

// optional .TransportStopsTree stops = 6;
inline bool FlcNavTransportIndex::has_stops() const {
  return _has_bit(2);
}
inline void FlcNavTransportIndex::clear_stops() {
  if (stops_ != NULL) stops_->::TransportStopsTree::Clear();
  _clear_bit(2);
}
inline const ::TransportStopsTree& FlcNavTransportIndex::stops() const {
  return stops_ != NULL ? *stops_ : *default_instance_->stops_;
}
inline ::TransportStopsTree* FlcNavTransportIndex::mutable_stops() {
  _set_bit(2);
  if (stops_ == NULL) stops_ = new ::TransportStopsTree;
  return stops_;
}

// required .StringTable stringTable = 9;
inline bool FlcNavTransportIndex::has_stringtable() const {
  return _has_bit(3);
}
inline void FlcNavTransportIndex::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(3);
}
inline const ::StringTable& FlcNavTransportIndex::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* FlcNavTransportIndex::mutable_stringtable() {
  _set_bit(3);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// FlcNavPoiIndex

// required string name = 1;
inline bool FlcNavPoiIndex::has_name() const {
  return _has_bit(0);
}
inline void FlcNavPoiIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavPoiIndex::name() const {
  return *name_;
}
inline void FlcNavPoiIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavPoiIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavPoiIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .FlcNavTileBox boundaries = 2;
inline bool FlcNavPoiIndex::has_boundaries() const {
  return _has_bit(1);
}
inline void FlcNavPoiIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::FlcNavTileBox::Clear();
  _clear_bit(1);
}
inline const ::FlcNavTileBox& FlcNavPoiIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::FlcNavTileBox* FlcNavPoiIndex::mutable_boundaries() {
  _set_bit(1);
  if (boundaries_ == NULL) boundaries_ = new ::FlcNavTileBox;
  return boundaries_;
}

// repeated .FlcNavCategoryTable categoriesTable = 3;
inline int FlcNavPoiIndex::categoriestable_size() const {
  return categoriestable_.size();
}
inline void FlcNavPoiIndex::clear_categoriestable() {
  categoriestable_.Clear();
}
inline const ::FlcNavCategoryTable& FlcNavPoiIndex::categoriestable(int index) const {
  return categoriestable_.Get(index);
}
inline ::FlcNavCategoryTable* FlcNavPoiIndex::mutable_categoriestable(int index) {
  return categoriestable_.Mutable(index);
}
inline ::FlcNavCategoryTable* FlcNavPoiIndex::add_categoriestable() {
  return categoriestable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavCategoryTable >&
FlcNavPoiIndex::categoriestable() const {
  return categoriestable_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavCategoryTable >*
FlcNavPoiIndex::mutable_categoriestable() {
  return &categoriestable_;
}

// optional .FlcNavPoiNameIndex nameIndex = 4;
inline bool FlcNavPoiIndex::has_nameindex() const {
  return _has_bit(3);
}
inline void FlcNavPoiIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::FlcNavPoiNameIndex::Clear();
  _clear_bit(3);
}
inline const ::FlcNavPoiNameIndex& FlcNavPoiIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::FlcNavPoiNameIndex* FlcNavPoiIndex::mutable_nameindex() {
  _set_bit(3);
  if (nameindex_ == NULL) nameindex_ = new ::FlcNavPoiNameIndex;
  return nameindex_;
}

// repeated .FlcNavPoiBox boxes = 6;
inline int FlcNavPoiIndex::boxes_size() const {
  return boxes_.size();
}
inline void FlcNavPoiIndex::clear_boxes() {
  boxes_.Clear();
}
inline const ::FlcNavPoiBox& FlcNavPoiIndex::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::FlcNavPoiBox* FlcNavPoiIndex::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::FlcNavPoiBox* FlcNavPoiIndex::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >&
FlcNavPoiIndex::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >*
FlcNavPoiIndex::mutable_boxes() {
  return &boxes_;
}

// repeated .FlcNavPoiBoxData poiData = 9;
inline int FlcNavPoiIndex::poidata_size() const {
  return poidata_.size();
}
inline void FlcNavPoiIndex::clear_poidata() {
  poidata_.Clear();
}
inline const ::FlcNavPoiBoxData& FlcNavPoiIndex::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::FlcNavPoiBoxData* FlcNavPoiIndex::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::FlcNavPoiBoxData* FlcNavPoiIndex::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxData >&
FlcNavPoiIndex::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxData >*
FlcNavPoiIndex::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// FlcNavPoiNameIndex_FlcNavPoiNameIndexData

// repeated .FlcNavPoiNameIndexDataAtom atoms = 3;
inline int FlcNavPoiNameIndex_FlcNavPoiNameIndexData::atoms_size() const {
  return atoms_.size();
}
inline void FlcNavPoiNameIndex_FlcNavPoiNameIndexData::clear_atoms() {
  atoms_.Clear();
}
inline const ::FlcNavPoiNameIndexDataAtom& FlcNavPoiNameIndex_FlcNavPoiNameIndexData::atoms(int index) const {
  return atoms_.Get(index);
}
inline ::FlcNavPoiNameIndexDataAtom* FlcNavPoiNameIndex_FlcNavPoiNameIndexData::mutable_atoms(int index) {
  return atoms_.Mutable(index);
}
inline ::FlcNavPoiNameIndexDataAtom* FlcNavPoiNameIndex_FlcNavPoiNameIndexData::add_atoms() {
  return atoms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndexDataAtom >&
FlcNavPoiNameIndex_FlcNavPoiNameIndexData::atoms() const {
  return atoms_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndexDataAtom >*
FlcNavPoiNameIndex_FlcNavPoiNameIndexData::mutable_atoms() {
  return &atoms_;
}

// -------------------------------------------------------------------

// FlcNavPoiNameIndex

// required .IndexedStringTable table = 3;
inline bool FlcNavPoiNameIndex::has_table() const {
  return _has_bit(0);
}
inline void FlcNavPoiNameIndex::clear_table() {
  if (table_ != NULL) table_->::IndexedStringTable::Clear();
  _clear_bit(0);
}
inline const ::IndexedStringTable& FlcNavPoiNameIndex::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::IndexedStringTable* FlcNavPoiNameIndex::mutable_table() {
  _set_bit(0);
  if (table_ == NULL) table_ = new ::IndexedStringTable;
  return table_;
}

// repeated .FlcNavPoiNameIndex.FlcNavPoiNameIndexData data = 5;
inline int FlcNavPoiNameIndex::data_size() const {
  return data_.size();
}
inline void FlcNavPoiNameIndex::clear_data() {
  data_.Clear();
}
inline const ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData& FlcNavPoiNameIndex::data(int index) const {
  return data_.Get(index);
}
inline ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData* FlcNavPoiNameIndex::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData* FlcNavPoiNameIndex::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData >&
FlcNavPoiNameIndex::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiNameIndex_FlcNavPoiNameIndexData >*
FlcNavPoiNameIndex::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// FlcNavPoiNameIndexDataAtom

// optional uint32 zoom = 2;
inline bool FlcNavPoiNameIndexDataAtom::has_zoom() const {
  return _has_bit(0);
}
inline void FlcNavPoiNameIndexDataAtom::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavPoiNameIndexDataAtom::zoom() const {
  return zoom_;
}
inline void FlcNavPoiNameIndexDataAtom::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 3;
inline bool FlcNavPoiNameIndexDataAtom::has_x() const {
  return _has_bit(1);
}
inline void FlcNavPoiNameIndexDataAtom::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 FlcNavPoiNameIndexDataAtom::x() const {
  return x_;
}
inline void FlcNavPoiNameIndexDataAtom::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 4;
inline bool FlcNavPoiNameIndexDataAtom::has_y() const {
  return _has_bit(2);
}
inline void FlcNavPoiNameIndexDataAtom::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 FlcNavPoiNameIndexDataAtom::y() const {
  return y_;
}
inline void FlcNavPoiNameIndexDataAtom::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// optional fixed32 shiftTo = 14;
inline bool FlcNavPoiNameIndexDataAtom::has_shiftto() const {
  return _has_bit(3);
}
inline void FlcNavPoiNameIndexDataAtom::clear_shiftto() {
  shiftto_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 FlcNavPoiNameIndexDataAtom::shiftto() const {
  return shiftto_;
}
inline void FlcNavPoiNameIndexDataAtom::set_shiftto(::google::protobuf::uint32 value) {
  _set_bit(3);
  shiftto_ = value;
}

// -------------------------------------------------------------------

// FlcNavCategoryTable

// required string category = 1;
inline bool FlcNavCategoryTable::has_category() const {
  return _has_bit(0);
}
inline void FlcNavCategoryTable::clear_category() {
  if (category_ != &_default_category_) {
    category_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavCategoryTable::category() const {
  return *category_;
}
inline void FlcNavCategoryTable::set_category(const ::std::string& value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void FlcNavCategoryTable::set_category(const char* value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void FlcNavCategoryTable::set_category(const char* value, size_t size) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavCategoryTable::mutable_category() {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  return category_;
}

// repeated string subcategories = 3;
inline int FlcNavCategoryTable::subcategories_size() const {
  return subcategories_.size();
}
inline void FlcNavCategoryTable::clear_subcategories() {
  subcategories_.Clear();
}
inline const ::std::string& FlcNavCategoryTable::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline ::std::string* FlcNavCategoryTable::mutable_subcategories(int index) {
  return subcategories_.Mutable(index);
}
inline void FlcNavCategoryTable::set_subcategories(int index, const ::std::string& value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void FlcNavCategoryTable::set_subcategories(int index, const char* value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void FlcNavCategoryTable::set_subcategories(int index, const char* value, size_t size) {
  subcategories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavCategoryTable::add_subcategories() {
  return subcategories_.Add();
}
inline void FlcNavCategoryTable::add_subcategories(const ::std::string& value) {
  subcategories_.Add()->assign(value);
}
inline void FlcNavCategoryTable::add_subcategories(const char* value) {
  subcategories_.Add()->assign(value);
}
inline void FlcNavCategoryTable::add_subcategories(const char* value, size_t size) {
  subcategories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FlcNavCategoryTable::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FlcNavCategoryTable::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// FlcNavPoiBox

// required uint32 zoom = 1;
inline bool FlcNavPoiBox::has_zoom() const {
  return _has_bit(0);
}
inline void FlcNavPoiBox::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavPoiBox::zoom() const {
  return zoom_;
}
inline void FlcNavPoiBox::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// required sint32 left = 2;
inline bool FlcNavPoiBox::has_left() const {
  return _has_bit(1);
}
inline void FlcNavPoiBox::clear_left() {
  left_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FlcNavPoiBox::left() const {
  return left_;
}
inline void FlcNavPoiBox::set_left(::google::protobuf::int32 value) {
  _set_bit(1);
  left_ = value;
}

// required sint32 top = 3;
inline bool FlcNavPoiBox::has_top() const {
  return _has_bit(2);
}
inline void FlcNavPoiBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FlcNavPoiBox::top() const {
  return top_;
}
inline void FlcNavPoiBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// optional .FlcNavPoiCategories categories = 4;
inline bool FlcNavPoiBox::has_categories() const {
  return _has_bit(3);
}
inline void FlcNavPoiBox::clear_categories() {
  if (categories_ != NULL) categories_->::FlcNavPoiCategories::Clear();
  _clear_bit(3);
}
inline const ::FlcNavPoiCategories& FlcNavPoiBox::categories() const {
  return categories_ != NULL ? *categories_ : *default_instance_->categories_;
}
inline ::FlcNavPoiCategories* FlcNavPoiBox::mutable_categories() {
  _set_bit(3);
  if (categories_ == NULL) categories_ = new ::FlcNavPoiCategories;
  return categories_;
}

// repeated .FlcNavPoiBox subBoxes = 10;
inline int FlcNavPoiBox::subboxes_size() const {
  return subboxes_.size();
}
inline void FlcNavPoiBox::clear_subboxes() {
  subboxes_.Clear();
}
inline const ::FlcNavPoiBox& FlcNavPoiBox::subboxes(int index) const {
  return subboxes_.Get(index);
}
inline ::FlcNavPoiBox* FlcNavPoiBox::mutable_subboxes(int index) {
  return subboxes_.Mutable(index);
}
inline ::FlcNavPoiBox* FlcNavPoiBox::add_subboxes() {
  return subboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >&
FlcNavPoiBox::subboxes() const {
  return subboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBox >*
FlcNavPoiBox::mutable_subboxes() {
  return &subboxes_;
}

// optional fixed32 shiftToData = 14;
inline bool FlcNavPoiBox::has_shifttodata() const {
  return _has_bit(5);
}
inline void FlcNavPoiBox::clear_shifttodata() {
  shifttodata_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 FlcNavPoiBox::shifttodata() const {
  return shifttodata_;
}
inline void FlcNavPoiBox::set_shifttodata(::google::protobuf::uint32 value) {
  _set_bit(5);
  shifttodata_ = value;
}

// -------------------------------------------------------------------

// FlcNavPoiCategories

// repeated uint32 categories = 3;
inline int FlcNavPoiCategories::categories_size() const {
  return categories_.size();
}
inline void FlcNavPoiCategories::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 FlcNavPoiCategories::categories(int index) const {
  return categories_.Get(index);
}
inline void FlcNavPoiCategories::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void FlcNavPoiCategories::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FlcNavPoiCategories::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FlcNavPoiCategories::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// FlcNavPoiBoxData

// optional uint32 zoom = 1;
inline bool FlcNavPoiBoxData::has_zoom() const {
  return _has_bit(0);
}
inline void FlcNavPoiBoxData::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 FlcNavPoiBoxData::zoom() const {
  return zoom_;
}
inline void FlcNavPoiBoxData::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 2;
inline bool FlcNavPoiBoxData::has_x() const {
  return _has_bit(1);
}
inline void FlcNavPoiBoxData::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 FlcNavPoiBoxData::x() const {
  return x_;
}
inline void FlcNavPoiBoxData::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 3;
inline bool FlcNavPoiBoxData::has_y() const {
  return _has_bit(2);
}
inline void FlcNavPoiBoxData::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 FlcNavPoiBoxData::y() const {
  return y_;
}
inline void FlcNavPoiBoxData::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// repeated .FlcNavPoiBoxDataAtom poiData = 5;
inline int FlcNavPoiBoxData::poidata_size() const {
  return poidata_.size();
}
inline void FlcNavPoiBoxData::clear_poidata() {
  poidata_.Clear();
}
inline const ::FlcNavPoiBoxDataAtom& FlcNavPoiBoxData::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::FlcNavPoiBoxDataAtom* FlcNavPoiBoxData::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::FlcNavPoiBoxDataAtom* FlcNavPoiBoxData::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxDataAtom >&
FlcNavPoiBoxData::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavPoiBoxDataAtom >*
FlcNavPoiBoxData::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// FlcNavPoiBoxDataAtom

// required sint32 dx = 2;
inline bool FlcNavPoiBoxDataAtom::has_dx() const {
  return _has_bit(0);
}
inline void FlcNavPoiBoxDataAtom::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FlcNavPoiBoxDataAtom::dx() const {
  return dx_;
}
inline void FlcNavPoiBoxDataAtom::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool FlcNavPoiBoxDataAtom::has_dy() const {
  return _has_bit(1);
}
inline void FlcNavPoiBoxDataAtom::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FlcNavPoiBoxDataAtom::dy() const {
  return dy_;
}
inline void FlcNavPoiBoxDataAtom::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// repeated uint32 categories = 4;
inline int FlcNavPoiBoxDataAtom::categories_size() const {
  return categories_.size();
}
inline void FlcNavPoiBoxDataAtom::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 FlcNavPoiBoxDataAtom::categories(int index) const {
  return categories_.Get(index);
}
inline void FlcNavPoiBoxDataAtom::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void FlcNavPoiBoxDataAtom::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FlcNavPoiBoxDataAtom::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FlcNavPoiBoxDataAtom::mutable_categories() {
  return &categories_;
}

// optional string name = 6;
inline bool FlcNavPoiBoxDataAtom::has_name() const {
  return _has_bit(3);
}
inline void FlcNavPoiBoxDataAtom::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::name() const {
  return *name_;
}
inline void FlcNavPoiBoxDataAtom::set_name(const ::std::string& value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_name(const char* value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_name(const char* value, size_t size) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_name() {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string nameEn = 7;
inline bool FlcNavPoiBoxDataAtom::has_nameen() const {
  return _has_bit(4);
}
inline void FlcNavPoiBoxDataAtom::clear_nameen() {
  if (nameen_ != &_default_nameen_) {
    nameen_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::nameen() const {
  return *nameen_;
}
inline void FlcNavPoiBoxDataAtom::set_nameen(const ::std::string& value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_nameen(const char* value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_nameen(const char* value, size_t size) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_nameen() {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}

// optional uint64 id = 8;
inline bool FlcNavPoiBoxDataAtom::has_id() const {
  return _has_bit(5);
}
inline void FlcNavPoiBoxDataAtom::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 FlcNavPoiBoxDataAtom::id() const {
  return id_;
}
inline void FlcNavPoiBoxDataAtom::set_id(::google::protobuf::uint64 value) {
  _set_bit(5);
  id_ = value;
}

// optional string openingHours = 10;
inline bool FlcNavPoiBoxDataAtom::has_openinghours() const {
  return _has_bit(6);
}
inline void FlcNavPoiBoxDataAtom::clear_openinghours() {
  if (openinghours_ != &_default_openinghours_) {
    openinghours_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::openinghours() const {
  return *openinghours_;
}
inline void FlcNavPoiBoxDataAtom::set_openinghours(const ::std::string& value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_openinghours(const char* value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_openinghours(const char* value, size_t size) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_openinghours() {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  return openinghours_;
}

// optional string site = 11;
inline bool FlcNavPoiBoxDataAtom::has_site() const {
  return _has_bit(7);
}
inline void FlcNavPoiBoxDataAtom::clear_site() {
  if (site_ != &_default_site_) {
    site_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::site() const {
  return *site_;
}
inline void FlcNavPoiBoxDataAtom::set_site(const ::std::string& value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_site(const char* value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_site(const char* value, size_t size) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_site() {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  return site_;
}

// optional string phone = 12;
inline bool FlcNavPoiBoxDataAtom::has_phone() const {
  return _has_bit(8);
}
inline void FlcNavPoiBoxDataAtom::clear_phone() {
  if (phone_ != &_default_phone_) {
    phone_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::phone() const {
  return *phone_;
}
inline void FlcNavPoiBoxDataAtom::set_phone(const ::std::string& value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_phone(const char* value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_phone(const char* value, size_t size) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_phone() {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  return phone_;
}

// optional string note = 13;
inline bool FlcNavPoiBoxDataAtom::has_note() const {
  return _has_bit(9);
}
inline void FlcNavPoiBoxDataAtom::clear_note() {
  if (note_ != &_default_note_) {
    note_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& FlcNavPoiBoxDataAtom::note() const {
  return *note_;
}
inline void FlcNavPoiBoxDataAtom::set_note(const ::std::string& value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_note(const char* value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void FlcNavPoiBoxDataAtom::set_note(const char* value, size_t size) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavPoiBoxDataAtom::mutable_note() {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  return note_;
}

// -------------------------------------------------------------------

// IdTable

// repeated sint64 routeId = 1;
inline int IdTable::routeid_size() const {
  return routeid_.size();
}
inline void IdTable::clear_routeid() {
  routeid_.Clear();
}
inline ::google::protobuf::int64 IdTable::routeid(int index) const {
  return routeid_.Get(index);
}
inline void IdTable::set_routeid(int index, ::google::protobuf::int64 value) {
  routeid_.Set(index, value);
}
inline void IdTable::add_routeid(::google::protobuf::int64 value) {
  routeid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
IdTable::routeid() const {
  return routeid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
IdTable::mutable_routeid() {
  return &routeid_;
}

// -------------------------------------------------------------------

// RestrictionData

// required int32 type = 1;
inline bool RestrictionData::has_type() const {
  return _has_bit(0);
}
inline void RestrictionData::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 RestrictionData::type() const {
  return type_;
}
inline void RestrictionData::set_type(::google::protobuf::int32 value) {
  _set_bit(0);
  type_ = value;
}

// required int32 from = 2;
inline bool RestrictionData::has_from() const {
  return _has_bit(1);
}
inline void RestrictionData::clear_from() {
  from_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 RestrictionData::from() const {
  return from_;
}
inline void RestrictionData::set_from(::google::protobuf::int32 value) {
  _set_bit(1);
  from_ = value;
}

// required int32 to = 3;
inline bool RestrictionData::has_to() const {
  return _has_bit(2);
}
inline void RestrictionData::clear_to() {
  to_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 RestrictionData::to() const {
  return to_;
}
inline void RestrictionData::set_to(::google::protobuf::int32 value) {
  _set_bit(2);
  to_ = value;
}

// optional int32 via = 4;
inline bool RestrictionData::has_via() const {
  return _has_bit(3);
}
inline void RestrictionData::clear_via() {
  via_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 RestrictionData::via() const {
  return via_;
}
inline void RestrictionData::set_via(::google::protobuf::int32 value) {
  _set_bit(3);
  via_ = value;
}

// -------------------------------------------------------------------

// RouteData

// required bytes points = 1;
inline bool RouteData::has_points() const {
  return _has_bit(0);
}
inline void RouteData::clear_points() {
  if (points_ != &_default_points_) {
    points_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RouteData::points() const {
  return *points_;
}
inline void RouteData::set_points(const ::std::string& value) {
  _set_bit(0);
  if (points_ == &_default_points_) {
    points_ = new ::std::string;
  }
  points_->assign(value);
}
inline void RouteData::set_points(const char* value) {
  _set_bit(0);
  if (points_ == &_default_points_) {
    points_ = new ::std::string;
  }
  points_->assign(value);
}
inline void RouteData::set_points(const void* value, size_t size) {
  _set_bit(0);
  if (points_ == &_default_points_) {
    points_ = new ::std::string;
  }
  points_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_points() {
  _set_bit(0);
  if (points_ == &_default_points_) {
    points_ = new ::std::string;
  }
  return points_;
}

// optional bytes pointTypes = 4;
inline bool RouteData::has_pointtypes() const {
  return _has_bit(1);
}
inline void RouteData::clear_pointtypes() {
  if (pointtypes_ != &_default_pointtypes_) {
    pointtypes_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RouteData::pointtypes() const {
  return *pointtypes_;
}
inline void RouteData::set_pointtypes(const ::std::string& value) {
  _set_bit(1);
  if (pointtypes_ == &_default_pointtypes_) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(value);
}
inline void RouteData::set_pointtypes(const char* value) {
  _set_bit(1);
  if (pointtypes_ == &_default_pointtypes_) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(value);
}
inline void RouteData::set_pointtypes(const void* value, size_t size) {
  _set_bit(1);
  if (pointtypes_ == &_default_pointtypes_) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_pointtypes() {
  _set_bit(1);
  if (pointtypes_ == &_default_pointtypes_) {
    pointtypes_ = new ::std::string;
  }
  return pointtypes_;
}

// optional bytes pointJNInd = 5;
inline bool RouteData::has_pointjnind() const {
  return _has_bit(2);
}
inline void RouteData::clear_pointjnind() {
  if (pointjnind_ != &_default_pointjnind_) {
    pointjnind_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RouteData::pointjnind() const {
  return *pointjnind_;
}
inline void RouteData::set_pointjnind(const ::std::string& value) {
  _set_bit(2);
  if (pointjnind_ == &_default_pointjnind_) {
    pointjnind_ = new ::std::string;
  }
  pointjnind_->assign(value);
}
inline void RouteData::set_pointjnind(const char* value) {
  _set_bit(2);
  if (pointjnind_ == &_default_pointjnind_) {
    pointjnind_ = new ::std::string;
  }
  pointjnind_->assign(value);
}
inline void RouteData::set_pointjnind(const void* value, size_t size) {
  _set_bit(2);
  if (pointjnind_ == &_default_pointjnind_) {
    pointjnind_ = new ::std::string;
  }
  pointjnind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_pointjnind() {
  _set_bit(2);
  if (pointjnind_ == &_default_pointjnind_) {
    pointjnind_ = new ::std::string;
  }
  return pointjnind_;
}

// optional bytes pointJNWayIds = 6;
inline bool RouteData::has_pointjnwayids() const {
  return _has_bit(3);
}
inline void RouteData::clear_pointjnwayids() {
  if (pointjnwayids_ != &_default_pointjnwayids_) {
    pointjnwayids_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RouteData::pointjnwayids() const {
  return *pointjnwayids_;
}
inline void RouteData::set_pointjnwayids(const ::std::string& value) {
  _set_bit(3);
  if (pointjnwayids_ == &_default_pointjnwayids_) {
    pointjnwayids_ = new ::std::string;
  }
  pointjnwayids_->assign(value);
}
inline void RouteData::set_pointjnwayids(const char* value) {
  _set_bit(3);
  if (pointjnwayids_ == &_default_pointjnwayids_) {
    pointjnwayids_ = new ::std::string;
  }
  pointjnwayids_->assign(value);
}
inline void RouteData::set_pointjnwayids(const void* value, size_t size) {
  _set_bit(3);
  if (pointjnwayids_ == &_default_pointjnwayids_) {
    pointjnwayids_ = new ::std::string;
  }
  pointjnwayids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_pointjnwayids() {
  _set_bit(3);
  if (pointjnwayids_ == &_default_pointjnwayids_) {
    pointjnwayids_ = new ::std::string;
  }
  return pointjnwayids_;
}

// required bytes types = 7;
inline bool RouteData::has_types() const {
  return _has_bit(4);
}
inline void RouteData::clear_types() {
  if (types_ != &_default_types_) {
    types_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& RouteData::types() const {
  return *types_;
}
inline void RouteData::set_types(const ::std::string& value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void RouteData::set_types(const char* value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void RouteData::set_types(const void* value, size_t size) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_types() {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  return types_;
}

// required int32 routeId = 12;
inline bool RouteData::has_routeid() const {
  return _has_bit(5);
}
inline void RouteData::clear_routeid() {
  routeid_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 RouteData::routeid() const {
  return routeid_;
}
inline void RouteData::set_routeid(::google::protobuf::int32 value) {
  _set_bit(5);
  routeid_ = value;
}

// optional bytes stringNames = 14;
inline bool RouteData::has_stringnames() const {
  return _has_bit(6);
}
inline void RouteData::clear_stringnames() {
  if (stringnames_ != &_default_stringnames_) {
    stringnames_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& RouteData::stringnames() const {
  return *stringnames_;
}
inline void RouteData::set_stringnames(const ::std::string& value) {
  _set_bit(6);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void RouteData::set_stringnames(const char* value) {
  _set_bit(6);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void RouteData::set_stringnames(const void* value, size_t size) {
  _set_bit(6);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_stringnames() {
  _set_bit(6);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  return stringnames_;
}

// -------------------------------------------------------------------

// FlcNavRoutingIndex_RouteEncodingRule

// required string tag = 3;
inline bool FlcNavRoutingIndex_RouteEncodingRule::has_tag() const {
  return _has_bit(0);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavRoutingIndex_RouteEncodingRule::tag() const {
  return *tag_;
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_tag(const ::std::string& value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_tag(const char* value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_tag(const char* value, size_t size) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavRoutingIndex_RouteEncodingRule::mutable_tag() {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// required string value = 5;
inline bool FlcNavRoutingIndex_RouteEncodingRule::has_value() const {
  return _has_bit(1);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FlcNavRoutingIndex_RouteEncodingRule::value() const {
  return *value_;
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavRoutingIndex_RouteEncodingRule::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional uint32 id = 7;
inline bool FlcNavRoutingIndex_RouteEncodingRule::has_id() const {
  return _has_bit(2);
}
inline void FlcNavRoutingIndex_RouteEncodingRule::clear_id() {
  id_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 FlcNavRoutingIndex_RouteEncodingRule::id() const {
  return id_;
}
inline void FlcNavRoutingIndex_RouteEncodingRule::set_id(::google::protobuf::uint32 value) {
  _set_bit(2);
  id_ = value;
}

// -------------------------------------------------------------------

// FlcNavRoutingIndex_RouteDataBox

// required sint32 left = 1;
inline bool FlcNavRoutingIndex_RouteDataBox::has_left() const {
  return _has_bit(0);
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FlcNavRoutingIndex_RouteDataBox::left() const {
  return left_;
}
inline void FlcNavRoutingIndex_RouteDataBox::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool FlcNavRoutingIndex_RouteDataBox::has_right() const {
  return _has_bit(1);
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FlcNavRoutingIndex_RouteDataBox::right() const {
  return right_;
}
inline void FlcNavRoutingIndex_RouteDataBox::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool FlcNavRoutingIndex_RouteDataBox::has_top() const {
  return _has_bit(2);
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FlcNavRoutingIndex_RouteDataBox::top() const {
  return top_;
}
inline void FlcNavRoutingIndex_RouteDataBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool FlcNavRoutingIndex_RouteDataBox::has_bottom() const {
  return _has_bit(3);
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 FlcNavRoutingIndex_RouteDataBox::bottom() const {
  return bottom_;
}
inline void FlcNavRoutingIndex_RouteDataBox::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// optional fixed32 shiftToData = 5;
inline bool FlcNavRoutingIndex_RouteDataBox::has_shifttodata() const {
  return _has_bit(4);
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_shifttodata() {
  shifttodata_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 FlcNavRoutingIndex_RouteDataBox::shifttodata() const {
  return shifttodata_;
}
inline void FlcNavRoutingIndex_RouteDataBox::set_shifttodata(::google::protobuf::uint32 value) {
  _set_bit(4);
  shifttodata_ = value;
}

// repeated .FlcNavRoutingIndex.RouteDataBox boxes = 7;
inline int FlcNavRoutingIndex_RouteDataBox::boxes_size() const {
  return boxes_.size();
}
inline void FlcNavRoutingIndex_RouteDataBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::FlcNavRoutingIndex_RouteDataBox& FlcNavRoutingIndex_RouteDataBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::FlcNavRoutingIndex_RouteDataBox* FlcNavRoutingIndex_RouteDataBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::FlcNavRoutingIndex_RouteDataBox* FlcNavRoutingIndex_RouteDataBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >&
FlcNavRoutingIndex_RouteDataBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >*
FlcNavRoutingIndex_RouteDataBox::mutable_boxes() {
  return &boxes_;
}

// -------------------------------------------------------------------

// FlcNavRoutingIndex_RouteDataBlock

// optional .IdTable idTable = 5;
inline bool FlcNavRoutingIndex_RouteDataBlock::has_idtable() const {
  return _has_bit(0);
}
inline void FlcNavRoutingIndex_RouteDataBlock::clear_idtable() {
  if (idtable_ != NULL) idtable_->::IdTable::Clear();
  _clear_bit(0);
}
inline const ::IdTable& FlcNavRoutingIndex_RouteDataBlock::idtable() const {
  return idtable_ != NULL ? *idtable_ : *default_instance_->idtable_;
}
inline ::IdTable* FlcNavRoutingIndex_RouteDataBlock::mutable_idtable() {
  _set_bit(0);
  if (idtable_ == NULL) idtable_ = new ::IdTable;
  return idtable_;
}

// optional .StringTable stringTable = 8;
inline bool FlcNavRoutingIndex_RouteDataBlock::has_stringtable() const {
  return _has_bit(1);
}
inline void FlcNavRoutingIndex_RouteDataBlock::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(1);
}
inline const ::StringTable& FlcNavRoutingIndex_RouteDataBlock::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* FlcNavRoutingIndex_RouteDataBlock::mutable_stringtable() {
  _set_bit(1);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// repeated .RouteData dataObjects = 6;
inline int FlcNavRoutingIndex_RouteDataBlock::dataobjects_size() const {
  return dataobjects_.size();
}
inline void FlcNavRoutingIndex_RouteDataBlock::clear_dataobjects() {
  dataobjects_.Clear();
}
inline const ::RouteData& FlcNavRoutingIndex_RouteDataBlock::dataobjects(int index) const {
  return dataobjects_.Get(index);
}
inline ::RouteData* FlcNavRoutingIndex_RouteDataBlock::mutable_dataobjects(int index) {
  return dataobjects_.Mutable(index);
}
inline ::RouteData* FlcNavRoutingIndex_RouteDataBlock::add_dataobjects() {
  return dataobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RouteData >&
FlcNavRoutingIndex_RouteDataBlock::dataobjects() const {
  return dataobjects_;
}
inline ::google::protobuf::RepeatedPtrField< ::RouteData >*
FlcNavRoutingIndex_RouteDataBlock::mutable_dataobjects() {
  return &dataobjects_;
}

// repeated .RestrictionData restrictions = 7;
inline int FlcNavRoutingIndex_RouteDataBlock::restrictions_size() const {
  return restrictions_.size();
}
inline void FlcNavRoutingIndex_RouteDataBlock::clear_restrictions() {
  restrictions_.Clear();
}
inline const ::RestrictionData& FlcNavRoutingIndex_RouteDataBlock::restrictions(int index) const {
  return restrictions_.Get(index);
}
inline ::RestrictionData* FlcNavRoutingIndex_RouteDataBlock::mutable_restrictions(int index) {
  return restrictions_.Mutable(index);
}
inline ::RestrictionData* FlcNavRoutingIndex_RouteDataBlock::add_restrictions() {
  return restrictions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RestrictionData >&
FlcNavRoutingIndex_RouteDataBlock::restrictions() const {
  return restrictions_;
}
inline ::google::protobuf::RepeatedPtrField< ::RestrictionData >*
FlcNavRoutingIndex_RouteDataBlock::mutable_restrictions() {
  return &restrictions_;
}

// -------------------------------------------------------------------

// FlcNavRoutingIndex

// required string name = 1;
inline bool FlcNavRoutingIndex::has_name() const {
  return _has_bit(0);
}
inline void FlcNavRoutingIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FlcNavRoutingIndex::name() const {
  return *name_;
}
inline void FlcNavRoutingIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavRoutingIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlcNavRoutingIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlcNavRoutingIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .FlcNavRoutingIndex.RouteEncodingRule rules = 2;
inline int FlcNavRoutingIndex::rules_size() const {
  return rules_.size();
}
inline void FlcNavRoutingIndex::clear_rules() {
  rules_.Clear();
}
inline const ::FlcNavRoutingIndex_RouteEncodingRule& FlcNavRoutingIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::FlcNavRoutingIndex_RouteEncodingRule* FlcNavRoutingIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::FlcNavRoutingIndex_RouteEncodingRule* FlcNavRoutingIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteEncodingRule >&
FlcNavRoutingIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteEncodingRule >*
FlcNavRoutingIndex::mutable_rules() {
  return &rules_;
}

// repeated .FlcNavRoutingIndex.RouteDataBox rootBoxes = 3;
inline int FlcNavRoutingIndex::rootboxes_size() const {
  return rootboxes_.size();
}
inline void FlcNavRoutingIndex::clear_rootboxes() {
  rootboxes_.Clear();
}
inline const ::FlcNavRoutingIndex_RouteDataBox& FlcNavRoutingIndex::rootboxes(int index) const {
  return rootboxes_.Get(index);
}
inline ::FlcNavRoutingIndex_RouteDataBox* FlcNavRoutingIndex::mutable_rootboxes(int index) {
  return rootboxes_.Mutable(index);
}
inline ::FlcNavRoutingIndex_RouteDataBox* FlcNavRoutingIndex::add_rootboxes() {
  return rootboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >&
FlcNavRoutingIndex::rootboxes() const {
  return rootboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBox >*
FlcNavRoutingIndex::mutable_rootboxes() {
  return &rootboxes_;
}

// repeated .FlcNavRoutingIndex.RouteDataBlock blocks = 5;
inline int FlcNavRoutingIndex::blocks_size() const {
  return blocks_.size();
}
inline void FlcNavRoutingIndex::clear_blocks() {
  blocks_.Clear();
}
inline const ::FlcNavRoutingIndex_RouteDataBlock& FlcNavRoutingIndex::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::FlcNavRoutingIndex_RouteDataBlock* FlcNavRoutingIndex::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::FlcNavRoutingIndex_RouteDataBlock* FlcNavRoutingIndex::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBlock >&
FlcNavRoutingIndex::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::FlcNavRoutingIndex_RouteDataBlock >*
FlcNavRoutingIndex::mutable_blocks() {
  return &blocks_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_flcnav_5fodb_2eproto__INCLUDED
